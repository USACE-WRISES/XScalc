<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>1D Cross-Section Hydraulics Calculator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg:#fff; --fg:#111; --muted:#666; --border:#ddd; --card:#fafafa;
      --blue:#0b57d0; --magenta:#c2185b; --green:#2e7d32; --dkgray:#444;
    }
    *{box-sizing:border-box;}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial,sans-serif;margin:0;color:var(--fg);background:#fff;}
    body.modal-open{overflow:hidden;overscroll-behavior:none;}
    header{padding:16px 20px;border-bottom:1px solid var(--border);font-weight:600;}
    main{max-width:1340px;margin:0 auto;padding:20px;display:grid;gap:20px;}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:16px;}
    h2{margin:0;font-size:1.07rem;}
    .small{font-size:.92rem;color:var(--muted);}
    .cardHdr{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;}
    .helpBtn{width:28px;height:28px;border-radius:50%;display:inline-flex;align-items:center;justify-content:center;border:1px solid #cfcfcf;background:#fff;color:#333;font-weight:600;cursor:pointer;}
    .helpBtn.clicked{animation:btnflash 180ms ease-out}
    /* Tabs */
    .tabs{display:flex;gap:16px;border-bottom:1px solid #e6e6e6;margin:4px 0 10px;}
    .tab{padding:8px 2px;cursor:pointer;color:#444;position:relative;font-weight:500;}
    .tab.active{color:#0b3d91;}
    .tab.active::after{content:"";position:absolute;left:0;right:0;bottom:-1px;height:2px;background:#0b57d0;border-radius:0;}
    .tabPanel{display:none;}
    .tabPanel.active{display:block;}
    /* Inputs grid */
    .controls{display:grid;grid-template-columns:repeat(5,minmax(180px,1fr));gap:12px;}
    label{display:grid;gap:6px;font-size:.92rem;color:var(--muted);}
    input,select,button{padding:10px;border:1px solid var(--border);border-radius:10px;font:inherit;background:#fff;}
    input,select{width:100%;}
    input:disabled, select:disabled { background:#f5f5f5; color:#888; }
    /* Accordion + small checkbox */
    details.acc{border:1px solid #e7e7e7;border-radius:10px;padding:8px 10px;background:#fff}
    details.acc+details.acc{margin-top:10px}
    details.acc>summary{cursor:pointer;list-style:none;user-select:none;font-weight:700;color:#333;margin:2px 0 8px;display:flex;align-items:center}
    details.acc>summary::-webkit-details-marker{display:none}
    /* Accordion caret */
    details.acc>summary::before{content:'\25B8'; /* ▸ */ display:inline-block; margin-right:6px; transition:transform .12s ease}
    details.acc[open]>summary::before{transform:rotate(90deg)}
    /* Unit tags */
    .unit-len{color:#666}
    .chk-sm{transform:scale(0.95); transform-origin:left center}
    .actions{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px;}
    .actions-xs{margin:4px 0 10px;}
    button{background:#fff;cursor:pointer;}
    button.clicked{animation:btnflash 180ms ease-out}
    @keyframes btnflash{0%{background:#fff}40%{background:#e9e9e9}100%{background:#fff}}
    .labelTitle{display:flex;align-items:center;gap:6px}
    .info{position:relative;display:inline-flex;align-items:center;justify-content:center;width:16px;height:16px;border-radius:50%;border:1px solid #bcbcbc;color:#555;background:#fff;font-size:11px;line-height:1;cursor:help;user-select:none}
    .info::after{content:attr(data-tip);position:absolute;left:50%;transform:translateX(-50%);bottom:130%;width:290px;max-width:70vw;padding:8px 10px;border-radius:8px;background:rgba(20,20,20,.95);color:#fff;font-size:12px;line-height:1.35;box-shadow:0 6px 16px rgba(0,0,0,.2);opacity:0;pointer-events:none;transition:opacity .12s ease-out;z-index:1000}
    .info::before{content:'';position:absolute;left:50%;transform:translateX(-50%);bottom:122%;border:6px solid transparent;border-top-color:rgba(20,20,20,.95);opacity:0;transition:opacity .12s ease-out}
    .info:hover::after,.info:hover::before{opacity:1}
    /* Two-pane */
    .grid2{display:grid;grid-template-columns:420px 880px;gap:16px;align-items:start}
    .resultsCard{width:880px}
    @media(max-width:1200px){.grid2{grid-template-columns:1fr}.resultsCard{width:auto}}
    @media(max-width:900px){.controls{grid-template-columns:repeat(3,minmax(160px,1fr))}}
    @media(max-width:600px){.controls{grid-template-columns:repeat(1,minmax(160px,1fr))}}
    /* Results header + switch */
    .resultsHeader{display:flex;align-items:center;gap:12px;margin-bottom:8px}
    .plotSwitch{margin-left:auto;display:flex;align-items:center;gap:8px}
    .segSwitch{display:inline-flex;border:1px solid #cfcfcf;border-radius:999px;overflow:hidden;background:#fff}
    .segSwitch input{display:none}
    .segSwitch label{padding:6px 10px;cursor:pointer;user-select:none;border-right:1px solid #e6e6e6;white-space:nowrap;font-size:.95rem}
    .segSwitch label:last-of-type{border-right:none}
    .segSwitch input:checked+label{background:#e9f0ff;color:#0b3d91}
    /* Tables */
    table{width:100%;border-collapse:separate;border-spacing:0;table-layout:fixed}
    /* Remove focus ring from the cross-section table when programmatically focused */
    #xsTable:focus, #xsTable:focus-visible{outline:none; box-shadow:none}
    th,td{padding:6px 8px;border-bottom:1px solid var(--border);border-right:1px solid var(--border)}
    th:last-child,td:last-child{border-right:none}
    th{text-align:left;color:#666;font-weight:600}
    td{text-align:left;background:#fff;user-select:none}
    /* XS table widths */
    #xsTable th:nth-child(1),#xsTable td.cell-id{width:28px}
    #xsTable th:nth-child(2),#xsTable td.cell-station{width:60px}
    #xsTable th:nth-child(3),#xsTable td.cell-elev{width:60px}
    #xsTable th:nth-child(4),#xsTable td.cell-stage{width:54px}
    #xsTable th:nth-child(5),#xsTable td.cell-n{width:58px}
    .cell-id{background:#f0f0f0;color:#333;text-align:center;font-variant-numeric:tabular-nums}
    .cell-station,.cell-elev{cursor:default}
    .cell-station input,.cell-elev input,.cell-stage select,.cell-n input{
      width:100%;border:none;outline:none;background:#fff;padding:8px 6px;border-radius:8px;text-align:left;cursor:default
    }
    .cell-stage select{ text-align:left; text-align-last:left; }
    .cell-station input:focus,.cell-elev input:focus,.cell-n input:focus{cursor:text;caret-color:#000}
    .cell-selected{background:#e6f0ff!important;box-shadow:inset 0 0 0 2px #bfd3ff}
    /* HVn show/hide */
    #xsTable th.col-n, #xsTable td.cell-n { display:none; }
    body.hvn-on #xsTable th.col-n, body.hvn-on #xsTable td.cell-n { display:table-cell; }
    body.hvn-on #nLOB, body.hvn-on #nMC, body.hvn-on #nROB { opacity:.5 }
    /* Results + overlays */
    .resultsWrap{display:grid;gap:10px}
    .plotWrap,.summaryWrap,.convWrap,.distWrap{position:relative}
    .overlayShade{position:absolute;inset:0;background:rgba(128,128,128,.35);border-radius:10px;display:none;pointer-events:none}
    .overlayNote{position:absolute;inset:0;display:none;align-items:center;justify-content:center;color:#111;font-weight:700;text-align:center;pointer-events:none;padding:0 12px}
    /* Plot */
    svg{width:100%;aspect-ratio:1000/360;height:auto;background:#fff;border:1px solid var(--border);border-radius:10px}
    .axis{stroke:#555;stroke-width:1.5;vector-effect:non-scaling-stroke}
    .grid{stroke:#888;stroke-width:1;stroke-dasharray:2 6;opacity:.55;vector-effect:non-scaling-stroke}
    .tick-mark{stroke:#333;stroke-width:2;vector-effect:non-scaling-stroke}
    .tick-label{font-size:20px;fill:#333}
    .axis-label{font-size:24px;fill:#222}
    .point{stroke:#222;fill:#222}
    .point.bank{stroke:#d32f2f;fill:#d32f2f}
    /* n labels (plot) */
    .nlabel { font-size:18px; fill:#333; }
    /* Profiles */
    .prof-vel{stroke:#b71c1c;stroke-width:2;fill:none;vector-effect:non-scaling-stroke}
    .prof-tau{stroke:#6f42c1;stroke-width:2;fill:none;vector-effect:non-scaling-stroke}
    /* Secondary axes */
    .secondary-axis{stroke:#333;stroke-width:1.5;vector-effect:non-scaling-stroke}
    .secondary-tick{stroke-width:2;vector-effect:non-scaling-stroke}
    .secondary-label{font-size:16px}
    /* Slice boundaries + tables */
    .slice-boundary{stroke:#777;stroke-width:1;stroke-dasharray:3 7;opacity:.55;vector-effect:non-scaling-stroke}
    .summary,.dist{width:100%;border-collapse:collapse;margin-top:4px;background:#fff;border:1px solid var(--border);border-radius:10px;overflow:hidden}
    .dist{table-layout:fixed}
    .summary th,.summary td,.dist th,.dist td{padding:10px 12px;border-bottom:1px solid var(--border);text-align:right}
    .summary th:first-child,.dist th:first-child{text-align:left}
    .dist th:first-child,.dist td:first-child{text-align:left;color:#444;white-space:nowrap}
    .dist tfoot td{font-weight:600;background:#fafafa}
    .disabled{opacity:.45;filter:grayscale(.6)}
    /* Summary widths */
    .summary{table-layout:auto}
    .summary th:first-child{min-width:220px;white-space:nowrap}
    .summary th:nth-child(2),.summary td:nth-child(2){min-width:130px;white-space:nowrap}
    /* HCS small tables */
    .subhdr{display:flex;align-items:center;gap:8px;margin:12px 0 6px;}
    .subhdr h4{margin:0;font-weight:500;color:#222;}
    .btnAdd{padding:4px 10px;border-radius:999px;border:1px solid #cfcfcf;font-size:.9rem;}
    .tbl-simple{width:100%;table-layout:fixed;border:1px solid #e8e8e8;border-radius:10px;overflow:hidden;background:#fff;}
    .tbl-simple th,.tbl-simple td{border-right:1px solid var(--border);border-bottom:1px solid var(--border);padding:8px 10px;}
    .tbl-simple th:last-child,.tbl-simple td:last-child{border-right:none;}
    .tbl-simple th{font-weight:400;color:#555;}
    .tbl-simple input{width:100%;padding:8px 8px;border:1px solid #e4e4e4;border-radius:8px;}
    .tbl-simple .actCol{width:64px;text-align:center;}
    .btnDel{padding:6px 8px;border-radius:8px;border:1px solid #e0e0e0;}
    .tbl-ifa colgroup col.c-l,.tbl-obs colgroup col.c-l{width:22%;}
    .tbl-ifa colgroup col.c-r,.tbl-obs colgroup col.c-r{width:22%;}
    .tbl-ifa colgroup col.c-elev{width:26%;}
    .tbl-obs colgroup col.c-top{width:36%;}
    .tbl-ifa colgroup col.c-perm{width:14%;}
    .tbl-ifa colgroup col.c-act,.tbl-obs colgroup col.c-act{width:10%;}
    .tbl-lev colgroup col.c-side{width:18%;}
    .tbl-lev colgroup col.c-en{width:16%;}
    .tbl-lev colgroup col.c-sta{width:33%;}
    .tbl-lev colgroup col.c-crest{width:33%;}
    /* n-picker + USGS modal */
    .modalBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:9999;overscroll-behavior:contain}
    .modal{width:min(980px,94vw);max-height:88vh;overflow:auto;background:#fff;border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,.28);padding:16px;display:grid;gap:8px;overscroll-behavior:contain}
    .modal.modal-lg{width:min(1180px,96vw);max-height:90vh;}
    .modal header{display:flex;align-items:center;justify-content:space-between;padding:0;border-bottom:none}
    .modal h3{margin:0;font-size:1.05rem}
    .modal .rightBtns{margin-left:auto;display:flex;gap:8px;align-items:center}
    .btnSecondary{border-color:#cfcfcf}
    .btnPrimary{background:#0b57d0;color:#fff;border-color:#0b57d0}
    .btnLink{border:none;background:transparent;color:#0b57d0;text-decoration:underline;padding:6px 8px;border-radius:8px}
    .pickerHeader{display:flex;align-items:center;gap:8px}
    .pickerHeader .rightBtns{margin-left:auto}
    .chips{display:flex;justify-content:center;gap:8px;margin:6px 0 8px}
    .chips button{padding:6px 10px;border-radius:999px;border:1px solid #cfcfcf;background:#fff}
    .chips button.active{background:#e9f0ff;color:#0b3d91}
    .centerRow{display:flex;justify-content:center;align-items:center;gap:8px;flex-wrap:wrap}
    .presetRow{margin:6px 0}
    .presetRow .title{font-weight:600;color:#333}
    .nValRow{margin:2px 0}
    .nValRow .val{font-weight:700}
    .quickGrid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:8px}
    .grp{border:1px solid #eee;border-radius:10px;padding:10px}
    .grp h4{margin:0 0 6px;font-size:.98rem;color:#333}
    .cards{display:grid;grid-template-columns:repeat(3,minmax(170px,1fr));gap:8px}
    @media(max-width:900px){.cards{grid-template-columns:repeat(2,minmax(160px,1fr))}}
    @media(max-width:600px){.cards{grid-template-columns:1fr}}
    .cardBtn{display:grid;gap:2px;border:1px solid #d9d9d9;border-radius:10px;padding:8px;background:#fff;text-align:left}
    .cardBtn.active{outline:2px solid #0b57d0}
    .cardBtn .lbl{font-weight:600;color:#222}
    .cardBtn .sub{font-size:.9rem;color:#555}
    .cardBtn .rng{font-size:.85rem;color:#777}
    .searchRow{display:flex;justify-content:center}
    .searchRow input{width:min(520px,85vw)}
    #nPickerMsg{ text-align:center;color:#b33;margin-top:6px;}
    /* Embedding USGS page */
    #usgsFrame{width:100%;height:78vh;border:none;border-radius:10px;background:#fff}
  </style>
</head>
<body>
<header>1D Cross-Section Hydraulics Calculator</header>

<main>
  <!-- SETTINGS -->
  <div class="card">
    <div class="cardHdr">
      <h2>Settings</h2>
      <button id="openHelp" class="helpBtn" title="About & equations">?</button>
    </div>

    <div class="tabs" role="tablist" aria-label="Settings Tabs">
      <div class="tab active" data-tab="setup" role="tab" aria-selected="true" tabindex="0">Setup</div>
      <div class="tab" data-tab="hcs" role="tab" aria-selected="false" tabindex="0">Hydraulic Controls &amp; Structures</div>
      <div class="tab" data-tab="designer" role="tab" aria-selected="false" tabindex="0">Designer</div>
    </div>

    <!-- Setup Panel -->
    <div id="tab-setup" class="tabPanel active">
      <div class="controls">
        <label>Unit system
          <select id="units">
            <option value="US">US Customary (ft, s)</option>
            <option value="SI">SI (m, s)</option>
          </select>
        </label>
        <label><span class="labelTitle">Bed/Energy Slope <span class="unit-slope">(ft/ft)</span></span>
          <input id="slope" type="number" step="0.001" value="0.001">
        </label>
        <label>LOB n
          <input id="nLOB" type="number" step="0.001" value="0.100">
        </label>
        <label>Channel n
          <input id="nMC" type="number" step="0.001" value="0.035">
        </label>
        <label>ROB n
          <input id="nROB" type="number" step="0.001" value="0.100">
        </label>
        <label><span class="labelTitle">Flow Depth <span class="unit-len">(ft)</span></span>
          <input id="depth" type="number" step="any" value="2.5">
        </label>
        <label><span class="labelTitle">Discharge <span class="unit-q unit-len">(ft³/s)</span></span>
          <input id="discharge" type="number" step="any" value="0" disabled>
        </label>
        <label>
          <span class="labelTitle">LOB slices <span class="info" data-tip="Up to 45 slices across LOB, Channel, and ROB combined.">i</span></span>
          <select id="N_LOB"></select>
        </label>
        <label>
          <span class="labelTitle">Channel slices <span class="info" data-tip="Up to 45 slices across LOB, Channel, and ROB combined.">i</span></span>
          <select id="N_CHAN"></select>
        </label>
        <label>
          <span class="labelTitle">ROB slices <span class="info" data-tip="Up to 45 slices across LOB, Channel, and ROB combined.">i</span></span>
          <select id="N_ROB"></select>
        </label>
        <label>Specify Discharge
          <input id="specifyQ" type="checkbox">
        </label>
        <label> Horizontal Variation of n
          <input id="hvnToggle" type="checkbox">
        </label>
      </div>
      <div class="actions">
        <button id="resetExample" class="harmonize">Reset Example</button>
        <button id="openNPicker" title="Open n‑value picker">Open n picker</button>
      </div>
    </div>

    <!-- HCS Panel -->
    <div id="tab-hcs" class="tabPanel">
      <div class="subhdr">
        <h4>Ineffective Flow Areas</h4>
        <button id="addIFA" class="btnAdd" title="Add IFA">Add</button>
      </div>
      <table id="ifaTable" class="tbl-simple tbl-ifa">
        <colgroup>
          <col class="c-l"><col class="c-r"><col class="c-elev"><col class="c-perm"><col class="c-act">
        </colgroup>
        <thead>
        <tr>
          <th>Left Sta</th>
          <th>Right Sta</th>
          <th>Effective Above Elev</th>
          <th>Permanent</th>
          <th class="actCol">Actions</th>
        </tr>
        </thead>
        <tbody></tbody>
      </table>

      <div class="subhdr" style="margin-top:14px;">
        <h4>Obstructions</h4>
        <button id="addOBS" class="btnAdd" title="Add Obstruction">Add</button>
      </div>
      <table id="obsTable" class="tbl-simple tbl-obs">
        <colgroup>
          <col class="c-l"><col class="c-r"><col class="c-top"><col class="c-act">
        </colgroup>
        <thead>
        <tr>
          <th>Left Sta</th>
          <th>Right Sta</th>
          <th>Top Elev</th>
          <th class="actCol">Actions</th>
        </tr>
        </thead>
        <tbody></tbody>
      </table>

      <div class="subhdr" style="margin-top:14px;">
        <h4>Levees</h4>
      </div>
      <table id="levTable" class="tbl-simple tbl-lev">
        <colgroup>
          <col class="c-side"><col class="c-en"><col class="c-sta"><col class="c-crest">
        </colgroup>
        <thead>
        <tr>
          <th>Side</th>
          <th>Enable</th>
          <th>Station</th>
          <th>Crest Elev</th>
        </tr>
        </thead>
        <tbody>
        <tr data-side="left">
          <td>Left</td>
          <td style="text-align:center"><input type="checkbox" class="lev-en"></td>
          <td><input type="number" step="any" class="lev-sta"></td>
          <td><input type="number" step="any" class="lev-crest"></td>
        </tr>
        <tr data-side="right">
          <td>Right</td>
          <td style="text-align:center"><input type="checkbox" class="lev-en"></td>
          <td><input type="number" step="any" class="lev-sta"></td>
          <td><input type="number" step="any" class="lev-crest"></td>
        </tr>
        </tbody>
      </table>
    </div>

    <!-- Designer Panel -->
    <div id="tab-designer" class="tabPanel">
      <div class="controls" style="margin-bottom:8px;">
        <label>
          <span class="labelTitle">Update XS Data</span>
          <input id="designerAutoApply" class="chk-sm" type="checkbox">
        </label>
        <label>
          Number of Stages
          <select id="des-numStages">
            <option value="1" selected>1</option>
            <option value="2">2</option>
            <option value="3">3</option>
          </select>
        </label>
      </div>

      <details class="acc" open>
        <summary>Stage 1 (Bankfull/Channel)</summary>
        <div class="controls">
          <label><span class="labelTitle">Width <span class="unit-len">(ft)</span></span>
            <input id="des-s1-Width" type="number" step="any" value="20">
          </label>
          <label><span class="labelTitle">Depth <span class="unit-len">(ft)</span></span>
            <input id="des-s1-Depth" type="number" step="any" value="2">
          </label>
          <label>Side Slope, m:1
            <input id="des-s1-mbanks" type="number" step="any" value="2">
          </label>
          <label>Bed Slope, ybed
            <input id="des-s1-ybed" type="number" step="any" value="0.5">
          </label>
          <label><span class="labelTitle">Thalweg Shift (+R/−L) <span class="unit-len">(ft)</span></span>
            <input id="des-s1-thalweg_shift" type="number" step="any" value="0">
          </label>
          <label><span class="labelTitle">Tie‑out L <span class="unit-len">(ft)</span></span>
            <input id="des-s1-Mtieout_L" type="number" step="any" value="3">
          </label>
          <label><span class="labelTitle">Tie‑out R <span class="unit-len">(ft)</span></span>
            <input id="des-s1-Mtieout_R" type="number" step="any" value="3">
          </label>
          <label>Roundness (0–1)
            <input id="des-s1-Roundness" type="number" min="0" max="1" step="any" value="0">
          </label>
        </div>
      </details>

      <details class="acc">
        <summary>Stage 2 (Benches)</summary>
        <div class="controls">
          <label><span class="labelTitle">ΔDepth <span class="unit-len">(ft)</span></span>
            <input id="des-s2-D2stg" type="number" step="any" value="2">
          </label>
          <label>Side Slope, m:1
            <input id="des-s2-Mbanks_2stg" type="number" step="any" value="2">
          </label>
          <label><span class="labelTitle">Bench L Width <span class="unit-len">(ft)</span></span>
            <input id="des-s2-Wbench_L" type="number" step="any" value="10">
          </label>
          <label><span class="labelTitle">Bench R Width <span class="unit-len">(ft)</span></span>
            <input id="des-s2-Wbench_R" type="number" step="any" value="10">
          </label>
          <label><span class="labelTitle">Bench L y <span class="unit-len">(ft)</span></span>
            <input id="des-s2-Ybench_L" type="number" step="any" value="0.2">
          </label>
          <label><span class="labelTitle">Bench R y <span class="unit-len">(ft)</span></span>
            <input id="des-s2-Ybench_R" type="number" step="any" value="0.2">
          </label>
          <label><span class="labelTitle">Tie‑out 2nd L <span class="unit-len">(ft)</span></span>
            <input id="des-s2-Mtieout_2stg_L" type="number" step="any" value="3">
          </label>
          <label><span class="labelTitle">Tie‑out 2nd R <span class="unit-len">(ft)</span></span>
            <input id="des-s2-Mtieout_2stg_R" type="number" step="any" value="3">
          </label>
        </div>
      </details>

      <details class="acc">
        <summary>Stage 3 (Floodplain)</summary>
        <div class="controls">
          <label><span class="labelTitle">ΔDepth <span class="unit-len">(ft)</span></span>
            <input id="des-s3-D3stg" type="number" step="any" value="0.5">
          </label>
          <label>Side Slope, m:1
            <input id="des-s3-Mbanks_3stg" type="number" step="any" value="2">
          </label>
          <label><span class="labelTitle">Stage 3 L Width <span class="unit-len">(ft)</span></span>
            <input id="des-s3-W3rdstage_L" type="number" step="any" value="10">
          </label>
          <label><span class="labelTitle">Stage 3 R Width <span class="unit-len">(ft)</span></span>
            <input id="des-s3-W3rdstage_R" type="number" step="any" value="10">
          </label>
          <label><span class="labelTitle">Stage 3 L y <span class="unit-len">(ft)</span></span>
            <input id="des-s3-y3rdStage_L" type="number" step="any" value="0.2">
          </label>
          <label><span class="labelTitle">Stage 3 R y <span class="unit-len">(ft)</span></span>
            <input id="des-s3-y3rdStage_R" type="number" step="any" value="0.2">
          </label>
          <label><span class="labelTitle">Tie‑out 3rd L <span class="unit-len">(ft)</span></span>
            <input id="des-s3-Mtieout_3stg_L" type="number" step="any" value="3">
          </label>
          <label><span class="labelTitle">Tie‑out 3rd R <span class="unit-len">(ft)</span></span>
            <input id="des-s3-Mtieout_3stg_R" type="number" step="any" value="3">
          </label>
        </div>
      </details>

      <details class="acc">
        <summary>Inner Berm</summary>
        <div class="controls">
          <label><span class="labelTitle">Inner Berm Enabled</span>
            <input id="des-isInnerBerm" class="chk-sm" type="checkbox">
          </label>
          <label><span class="labelTitle">WIB <span class="unit-len">(ft)</span></span>
            <input id="des-ib-WIB" type="number" step="any" value="1">
          </label>
          <label><span class="labelTitle">DmaxIB <span class="unit-len">(ft)</span></span>
            <input id="des-ib-DmaxIB" type="number" step="any" value="0.5">
          </label>
        </div>
      </details>

      <details class="acc">
        <summary>Advanced</summary>
        <div class="controls">
          <label>Left BKF H Mult
            <input id="des-adv-Left_BKF_Height_Multiplier" type="number" step="any" value="1">
          </label>
          <label>Right BKF H Mult
            <input id="des-adv-Right_BKF_Height_Multiplier" type="number" step="any" value="1">
          </label>
          <label>Left m@BKF Mult
            <input id="des-adv-Left_Mbanks_BKF_Multiplier" type="number" step="any" value="1">
          </label>
          <label>Right m@BKF Mult
            <input id="des-adv-Right_Mbanks_BKF_Multiplier" type="number" step="any" value="1">
          </label>
          <label>Left BKF bottom y Mult
            <input id="des-adv-Left_BKF_Bottom_Slope_Multiplier" type="number" step="any" value="1">
          </label>
          <label>Right BKF bottom y Mult
            <input id="des-adv-Right_BKF_Bottom_Slope_Multiplier" type="number" step="any" value="1">
          </label>
          <label><span class="labelTitle">X datum <span class="unit-len">(ft)</span></span>
            <input id="des-adv-X_datum" type="number" step="any" value="0">
          </label>
          <label><span class="labelTitle">Y datum <span class="unit-len">(ft)</span></span>
            <input id="des-adv-Y_datum" type="number" step="any" value="0">
          </label>
        </div>
      </details>

      <div class="actions" style="margin-top:10px;">
        <button id="designerApply">Apply</button>
      </div>
    </div>
  </div>

  <div class="grid2">
    <!-- CROSS‑SECTION -->
    <div class="card">
      <div class="cardHdr">
        <h2>Cross‑Section Data</h2>
        <button id="open3DEP" class="btnSecondary" title="Import a USGS 3DEP profile">Import 3DEP</button>
      </div>
      <p class="small">
        Stations increase left→right. Flow depth is from the lowest bed elevation (thalweg).
        Mark exactly one <strong>LB</strong> and one <strong>RB</strong> row to split into
        <em>Left Overbank</em>, <em>Main Channel</em>, and <em>Right Overbank</em>.
      </p>
      <div class="actions actions-xs">
        <button id="insertRow">Insert Row</button>
        <button id="deleteSelected" class="harmonize">Delete Selected</button>
        <button id="sortBtn" class="harmonize" title="Sort stations ascending">Sort by Station</button>
      </div>
      <table id="xsTable" tabindex="-1">
        <thead>
        <tr>
          <th>ID</th>
          <th>Station</th>
          <th>Elevation</th>
          <th>Stage</th>
          <th class="col-n">n</th>
        </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- RESULTS -->
    <div class="card resultsWrap resultsCard">
      <div class="resultsHeader">
        <h2>Results</h2>
        <div class="plotSwitch" title="Plot depth-averaged Velocity (V) and Shear (τ)">
          <div class="segSwitch" role="radiogroup" aria-label="Plot V, τ mode">
            <input id="pmOff" type="radio" name="plotMode" value="off" checked><label for="pmOff">Off</label>
            <input id="pmXS" type="radio" name="plotMode" value="xs"><label for="pmXS">V, τ (XS Avg)</label>
            <input id="pmSlices" type="radio" name="plotMode" value="slices"><label for="pmSlices">V, τ (Slices)</label>
          </div>
        </div>
      </div>

      <div class="plotWrap">
        <svg id="plot" viewBox="0 0 1000 360" preserveAspectRatio="xMidYMid meet" aria-label="Cross-section plot"></svg>
        <div class="overlayShade" id="plotShade"></div>
        <div class="overlayNote" id="plotNote"></div>
      </div>

      <div class="summaryWrap">
        <table id="summary" class="summary"></table>
        <div class="overlayShade" id="resultsShade"></div>
        <div class="overlayNote" id="resultsNote"></div>
      </div>

      <div class="convWrap">
        <h3>Conveyance by n‑breaks</h3>
        <table id="convTable" class="dist"></table>
        <div class="overlayShade" id="convShade"></div>
        <div class="overlayNote" id="convNote"></div>
      </div>

      <div class="distWrap">
        <h3 style="margin:8px 0 6px;font-size:1rem;">Flow Distribution Detailed Output</h3>
        <table id="distTable" class="dist"></table>
        <div class="overlayShade" id="distShade"></div>
        <div class="overlayNote" id="distNote"></div>
      </div>

      <p class="small" id="messages"></p>
    </div>
  </div>
</main>

<!-- Help Modal -->
<div id="helpModal" class="modalBackdrop" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div class="modal">
    <header>
      <h3 id="helpTitle">About this tool & formulas</h3>
      <div class="rightBtns"><button id="closeHelp" class="btnLink" aria-label="Close">Close</button></div>
    </header>
    <div class="helpContent">
      <div class="helpPane">
        <h4>Overview</h4>
        <p>
          This web app computes 1D open‑channel hydraulics for a single cross‑section using <em>Manning’s equation</em>.
          Provide station–elevation geometry, mark Left/Right Bank to form a compound channel (Left Overbank, Main Channel, Right Overbank),
          enter bed/energy slope <em>S</em>, and a flow depth <em>D</em> (measured from the thalweg). Optionally enable
          <b>Horizontal Variation of n</b> to assign roughness by station with carry‑forward n between breaks.
        </p>
        <p>Units: US (ft, s) with <em>k</em>=<b>1.486</b>, <em>γ</em>=62.4 lb/ft³, <em>g</em>=32.174 ft/s²; or SI (m, s) with <em>k</em>=1.0, <em>γ</em>=9810 N/m³, <em>g</em>=9.80665 m/s².</p>
      </div>
      <div class="helpPane">
        <h4>Equations Used</h4>
        <div class="eq">Water surface: &nbsp; WSE = <span class="i">z</span><sub>thalweg</sub> + <span class="i">D</span></div>
        <div class="eq">Hydraulic radius: &nbsp; <span class="i">R</span> = <span class="i">A</span> / <span class="i">P</span></div>
        <div class="eq">Hydraulic depth: &nbsp; <span class="i">D</span><sub>avg</sub> = <span class="i">A</span> / <span class="i">T</span><sub>w</sub></div>
        <div class="eq">Conveyance (per part): &nbsp; <span class="i">K</span> = (<span class="i">k</span>/<span class="i">n</span>) · <span class="i">A</span> · <span class="i">R</span><sup>2/3</sup></div>
        <div class="eq">Compound conveyance: &nbsp; <span class="i">K</span><sub>TOT</sub> = Σ <span class="i">K</span><sub>parts</sub></div>
        <div class="eq">Total discharge: &nbsp; <span class="i">Q</span> = <span class="i">K</span><sub>TOT</sub> · √<span class="i">S</span></div>
        <div class="eq">Velocity: &nbsp; <span class="i">V</span> = <span class="i">Q</span> / <span class="i">A</span></div>
        <div class="eq">Boundary shear: &nbsp; τ = <span class="i">γ</span> · <span class="i">R</span> · <span class="i">S</span></div>
        <div class="eq">Unit stream power: &nbsp; <span class="i">p</span> = τ · <span class="i">V</span></div>
        <div class="eq">Froude number: &nbsp; Fr = <span class="i">V</span> / √(<span class="i">g</span>·<span class="i">D</span><sub>avg</sub>)</div>
        <div class="eq"><small>HVn: overbanks subdivided at n‑breaks; channel uses n‑breaks or a composite n if either bank slope is steeper than 5H:1V and multiple n values exist.</small></div>
      </div>
    </div>
  </div>
</div>

<!-- n Picker Modal -->
<div id="nPickerModal" class="modalBackdrop" role="dialog" aria-modal="true" aria-labelledby="nPickerTitle">
  <div class="modal">
    <header class="pickerHeader">
      <h3 id="nPickerTitle">Roughness (Manning’s n) Picker</h3>
      <div class="rightBtns">
        <button id="applyN" class="btnSecondary" title="Apply to selected segment">Apply</button>
        <button id="applyCloseN" class="btnPrimary" title="Apply and close">Apply & Close</button>
        <button id="closeNPicker" class="btnLink" aria-label="Close">Close</button>
      </div>
    </header>
    <div class="chips">
      <button data-seg="lob">Left Overbank (LOB)</button>
      <button data-seg="chan" class="active">Channel</button>
      <button data-seg="rob">Right Overbank (ROB)</button>
    </div>
    <div class="centerRow presetRow">
      <span class="title">Preset:</span>
      <button class="preset" data-a="min">MIN</button>
      <button class="preset active" data-a="typ">TYP</button>
      <button class="preset" data-a="max">MAX</button>
    </div>
    <div class="centerRow nValRow">
      <span>n =&nbsp;<span id="nCurVal" class="val">0.035</span></span>
      <button id="nMinus">-0.001</button>
      <button id="nPlus">+0.001</button>
    </div>
    <div class="searchRow">
      <input id="nSearch" placeholder="Search (e.g., 'winding', 'concrete', 'brush')" />
    </div>
    <div id="nCardGrid" class="quickGrid"></div>
    <div class="small" id="nPickerMsg"></div>
  </div>
</div>

<!-- USGS (3DEP) Import Modal -->
<div id="usgsModal" class="modalBackdrop" role="dialog" aria-modal="true" aria-labelledby="usgsTitle">
  <div class="modal modal-lg" style="padding:0;display:block;">
    <!-- We keep the modal chrome minimal; usgs.html supplies its own toolbar including Import/Close -->
    <iframe id="usgsFrame" title="USGS 3DEP Import" src="about:blank"></iframe>
  </div>
</div>

<script src="designer.js"></script>
<script>
/* ===================== n CATALOG (complete) ===================== */
const N_CATALOG = [
  {id:'mc-clean-straight', grp:'Main Channels', label:'Clean: straight; full; no rifts or deep pools', n:{min:0.025,typ:0.030,max:0.033}},
  {id:'mc-more-stones-weeds', grp:'Main Channels', label:'Same as above: more stones & weeds', n:{min:0.030,typ:0.035,max:0.040}},
  {id:'mc-clean-winding', grp:'Main Channels', label:'Clean: winding; some pools & shoals', n:{min:0.033,typ:0.040,max:0.045}},
  {id:'mc-winding-some-weeds-stones', grp:'Main Channels', label:'Winding: some weeds & stones', n:{min:0.035,typ:0.045,max:0.050}},
  {id:'mc-lower-stage-ineffective', grp:'Main Channels', label:'Lower stages: more ineffective slopes/sections', n:{min:0.040,typ:0.048,max:0.055}},
  {id:'mc-more-stones', grp:'Main Channels', label:'Same as “lower stages”: more stones', n:{min:0.045,typ:0.050,max:0.060}},
  {id:'mc-sluggish-weedy', grp:'Main Channels', label:'Sluggish; weedy; deep pools', n:{min:0.050,typ:0.070,max:0.080}},
  {id:'mc-very-weedy-or-timber', grp:'Main Channels', label:'Very weedy; deep pools; or floodways with timber/brush', n:{min:0.070,typ:0.100,max:0.150}},

  {id:'fp-pasture-short', grp:'Floodplains', label:'Pasture (no brush): short grass', n:{min:0.025,typ:0.030,max:0.035}},
  {id:'fp-pasture-high', grp:'Floodplains', label:'Pasture (no brush): high grass', n:{min:0.030,typ:0.035,max:0.050}},
  {id:'fp-cultivated-none', grp:'Floodplains', label:'Cultivated: no crop', n:{min:0.020,typ:0.030,max:0.040}},
  {id:'fp-cultivated-row', grp:'Floodplains', label:'Cultivated: mature row crops', n:{min:0.025,typ:0.035,max:0.045}},
  {id:'fp-cultivated-field', grp:'Floodplains', label:'Cultivated: mature field crops', n:{min:0.030,typ:0.040,max:0.050}},
  {id:'fp-brush-scattered', grp:'Floodplains', label:'Brush: scattered; heavy weeds', n:{min:0.035,typ:0.050,max:0.070}},
  {id:'fp-brush-light-winter', grp:'Floodplains', label:'Brush: light brush & trees (winter)', n:{min:0.035,typ:0.050,max:0.060}},
  {id:'fp-brush-light-summer', grp:'Floodplains', label:'Brush: light brush & trees (summer)', n:{min:0.040,typ:0.060,max:0.080}},
  {id:'fp-brush-med-dense-winter', grp:'Floodplains', label:'Brush: medium–dense (winter)', n:{min:0.045,typ:0.070,max:0.110}},
  {id:'fp-brush-med-dense-summer', grp:'Floodplains', label:'Brush: medium–dense (summer)', n:{min:0.070,typ:0.100,max:0.160}},
  {id:'fp-trees-cleared-stumps', grp:'Floodplains', label:'Trees: cleared land; stumps; no sprouts', n:{min:0.030,typ:0.040,max:0.050}},
  {id:'fp-trees-heavy-sprouts', grp:'Floodplains', label:'Trees: heavy sprouts', n:{min:0.050,typ:0.060,max:0.080}},
  {id:'fp-trees-heavy-stand', grp:'Floodplains', label:'Trees: heavy stand; few down trees; little undergrowth; flow below branches', n:{min:0.080,typ:0.100,max:0.120}},
  {id:'fp-trees-flow-into-branches', grp:'Floodplains', label:'Trees: as above—flow into branches', n:{min:0.100,typ:0.120,max:0.160}},
  {id:'fp-dense-willows-summer', grp:'Floodplains', label:'Dense willows (summer; straight)', n:{min:0.110,typ:0.150,max:0.200}},

  {id:'ms-gravel-cobbles', grp:'Mountain Streams', label:'Bottom: gravels; cobbles; few boulders', n:{min:0.030,typ:0.040,max:0.050}},
  {id:'ms-cobbles-large-boulders', grp:'Mountain Streams', label:'Bottom: cobbles with large boulders', n:{min:0.040,typ:0.050,max:0.070}},

  {id:'ln-conc-trowel', grp:'Lined or Constructed Channels', label:'Concrete: trowel finish', n:{min:0.011,typ:0.013,max:0.015}},
  {id:'ln-conc-float', grp:'Lined or Constructed Channels', label:'Concrete: float finish', n:{min:0.013,typ:0.015,max:0.016}},
  {id:'ln-conc-gravel-bottom', grp:'Lined or Constructed Channels', label:'Concrete: finished; gravel bottom', n:{min:0.015,typ:0.017,max:0.020}},
  {id:'ln-conc-unfinished', grp:'Lined or Constructed Channels', label:'Concrete: unfinished', n:{min:0.014,typ:0.017,max:0.020}},
  {id:'ln-conc-gunite-good', grp:'Lined or Constructed Channels', label:'Concrete: gunite; good section', n:{min:0.016,typ:0.019,max:0.023}},
  {id:'ln-conc-gunite-wavy', grp:'Lined or Constructed Channels', label:'Concrete: gunite; wavy section', n:{min:0.018,typ:0.022,max:0.025}},
  {id:'ln-conc-good-rock', grp:'Lined or Constructed Channels', label:'Concrete: on good excavated rock', n:{min:0.017,typ:0.020,max:null}},
  {id:'ln-conc-irreg-rock', grp:'Lined or Constructed Channels', label:'Concrete: on irregular excavated rock', n:{min:0.022,typ:0.027,max:null}},
  {id:'ln-conc-bottom-dressed-stone', grp:'Lined or Constructed Channels', label:'Concrete bottom (float): sides—dressed stone in mortar', n:{min:0.015,typ:0.017,max:0.020}},
  {id:'ln-conc-bottom-rand-stone', grp:'Lined or Constructed Channels', label:'Concrete bottom (float): sides—random stone in mortar', n:{min:0.017,typ:0.020,max:0.024}},
  {id:'ln-conc-bottom-rubble-plaster', grp:'Lined or Constructed Channels', label:'Concrete bottom (float): sides—cement rubble masonry, plastered', n:{min:0.016,typ:0.020,max:0.024}},
  {id:'ln-conc-bottom-rubble', grp:'Lined or Constructed Channels', label:'Concrete bottom (float): sides—cement rubble masonry', n:{min:0.020,typ:0.025,max:0.030}},
  {id:'ln-conc-bottom-riprap', grp:'Lined or Constructed Channels', label:'Concrete bottom (float): sides—dry rubble or riprap', n:{min:0.020,typ:0.030,max:0.035}},
  {id:'ln-gravel-bottom-formed-conc', grp:'Lined or Constructed Channels', label:'Gravel bottom: sides—formed concrete', n:{min:0.017,typ:0.020,max:0.025}},
  {id:'ln-gravel-bottom-rand-stone', grp:'Lined or Constructed Channels', label:'Gravel bottom: sides—random stone in mortar', n:{min:0.020,typ:0.023,max:0.026}},
  {id:'ln-gravel-bottom-riprap', grp:'Lined or Constructed Channels', label:'Gravel bottom: sides—dry rubble or riprap', n:{min:0.023,typ:0.033,max:0.036}},
  {id:'ln-brick-glazed', grp:'Lined or Constructed Channels', label:'Brick: glazed', n:{min:0.011,typ:0.013,max:0.015}},
  {id:'ln-brick-mortar', grp:'Lined or Constructed Channels', label:'Brick: in cement mortar', n:{min:0.012,typ:0.015,max:0.018}},
  {id:'ln-metal-smooth', grp:'Lined or Constructed Channels', label:'Metal: smooth steel surfaces', n:{min:0.011,typ:0.012,max:0.014}},
  {id:'ln-metal-corrugated', grp:'Lined or Constructed Channels', label:'Metal: corrugated', n:{min:0.021,typ:0.025,max:0.030}},
  {id:'ln-asphalt-smooth', grp:'Lined or Constructed Channels', label:'Asphalt: smooth', n:{min:0.013,typ:0.013,max:null}},
  {id:'ln-asphalt-rough', grp:'Lined or Constructed Channels', label:'Asphalt: rough', n:{min:0.016,typ:0.016,max:null}},
  {id:'ln-vegetal-lining', grp:'Lined or Constructed Channels', label:'Vegetal lining', n:{min:0.030,typ:0.030,max:0.500}},

  {id:'ex-earth-straight-clean-new', grp:'Excavated or Dredged Channels', label:'Earth: straight & uniform—clean; recently completed', n:{min:0.016,typ:0.018,max:0.020}},
  {id:'ex-earth-straight-weathered', grp:'Excavated or Dredged Channels', label:'Earth: straight & uniform—clean; after weathering', n:{min:0.018,typ:0.022,max:0.025}},
  {id:'ex-earth-straight-gravel', grp:'Excavated or Dredged Channels', label:'Earth: straight & uniform—gravel; uniform; clean', n:{min:0.022,typ:0.025,max:0.030}},
  {id:'ex-earth-straight-short-grass', grp:'Excavated or Dredged Channels', label:'Earth: straight & uniform—with short grass; few weeds', n:{min:0.022,typ:0.027,max:0.033}},
  {id:'ex-earth-winding-none', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—no vegetation', n:{min:0.023,typ:0.025,max:0.030}},
  {id:'ex-earth-winding-grass', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—grass; some weeds', n:{min:0.025,typ:0.030,max:0.033}},
  {id:'ex-earth-winding-dense-weeds', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—dense weeds or aquatic plants (deep)', n:{min:0.030,typ:0.035,max:0.040}},
  {id:'ex-earth-winding-rubble-side', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—earth bottom; rubble sides', n:{min:0.028,typ:0.030,max:0.035}},
  {id:'ex-earth-winding-stony-weedy', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—stony bottom; weedy banks', n:{min:0.025,typ:0.035,max:0.040}},
  {id:'ex-earth-winding-cobble-clean', grp:'Excavated or Dredged Channels', label:'Earth: winding & sluggish—cobble bottom; clean sides', n:{min:0.030,typ:0.040,max:0.050}},
  {id:'ex-dragline-none', grp:'Excavated or Dredged Channels', label:'Dragline‑excavated / dredged—no vegetation', n:{min:0.025,typ:0.028,max:0.033}},
  {id:'ex-dragline-light-brush', grp:'Excavated or Dredged Channels', label:'Dragline‑excavated / dredged—light brush on banks', n:{min:0.035,typ:0.050,max:0.060}},
  {id:'ex-rock-smooth', grp:'Excavated or Dredged Channels', label:'Rock cuts: smooth & uniform', n:{min:0.025,typ:0.035,max:0.040}},
  {id:'ex-rock-jagged', grp:'Excavated or Dredged Channels', label:'Rock cuts: jagged & irregular', n:{min:0.035,typ:0.040,max:0.050}},
  {id:'ex-not-maintained-clean-bottom', grp:'Excavated or Dredged Channels', label:'Not maintained: clean bottom; brush on sides', n:{min:0.040,typ:0.050,max:0.080}},
  {id:'ex-not-maintained-high-stage', grp:'Excavated or Dredged Channels', label:'Not maintained: as above—highest stage', n:{min:0.045,typ:0.070,max:0.110}},
  {id:'ex-not-maintained-dense-weeds', grp:'Excavated or Dredged Channels', label:'Not maintained: dense weeds—height ≈ flow depth', n:{min:0.050,typ:0.080,max:0.120}},
  {id:'ex-not-maintained-dense-brush', grp:'Excavated or Dredged Channels', label:'Not maintained: dense brush—high stage', n:{min:0.080,typ:0.100,max:0.140}},
];

/* ===================== XS TABLE & UI ===================== */
const tableBody = document.querySelector('#xsTable tbody');

function createRowElement(station='', elevation='', stageTag='', nVal=''){
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td class="cell-id"></td>
    <td class="cell-station"><input type="text" inputmode="decimal" class="station" value="${station}"></td>
    <td class="cell-elev"><input type="text" inputmode="decimal" class="elevation" value="${elevation}"></td>
    <td class="cell-stage">
      <select class="stagetag" title="Stage tag (LB/RB)">
        <option value=""></option>
        <option value="LB">LB</option>
        <option value="RB">RB</option>
      </select>
    </td>
    <td class="cell-n"><input type="text" inputmode="decimal" class="nval" value="${nVal}"></td>
  `;
  tr.querySelector('.stagetag').value = stageTag;
  return tr;
}

function addRow(station='',elevation='',stageTag='', nVal='', beforeRow=null){
  const tr = createRowElement(station,elevation,stageTag,nVal);
  if(beforeRow) tableBody.insertBefore(tr,beforeRow);
  else tableBody.appendChild(tr);
  renumberIDs();
  return tr;
}
function renumberIDs(){
  [...tableBody.querySelectorAll('tr')].forEach((r,i)=>{
    const id = r.querySelector('.cell-id');
    if(id) id.textContent = (i+1);
  });
}
function isLastRow(tr){
  const rows=[...tableBody.querySelectorAll('tr')];
  return rows.length && rows[rows.length-1]===tr;
}
function ensureTrailingBlankRow(){
  const rows=[...tableBody.querySelectorAll('tr')];
  if(!rows.length){ addRow('','','',''); return; }
  const last=rows[rows.length-1];
  const s=last.querySelector('.station')?.value??'';
  const e=last.querySelector('.elevation')?.value??'';
  if(s!==''||e!=='') addRow('','','','');
}
function getRows(){ return [...tableBody.querySelectorAll('tr')]; }
function rowIndexOf(tr){ return getRows().indexOf(tr); }

/* Read rows (including stage and n) */
function getPointsWithStagesRaw(){
  const pts=[];
  getRows().forEach(r=>{
    const sx=r.querySelector('.station').value, ex=r.querySelector('.elevation').value;
    const nx=r.querySelector('.nval')?.value ?? '';
    const x=parseFloat(sx), z=parseFloat(ex);
    const tag=(r.querySelector('.stagetag')?.value)||'';
    const n=(nx.trim()===''? NaN : parseFloat(nx));
    if(Number.isFinite(x)&&Number.isFinite(z)) pts.push({x,z,tag, n: Number.isFinite(n)? n : NaN});
  });
  return pts;
}

/* Validate stage uniqueness */
function enforceUniqueStageTag(sel){
  const v=sel.value;
  if(v==='LB'||v==='RB'){
    for(const s of tableBody.querySelectorAll('.stagetag')) if(s!==sel && s.value===v) s.value='';
  }
}

/* Sorting preserves stage/n */
function sortTable(){
  const rows=getPointsWithStagesRaw().slice().sort((a,b)=>a.x-b.x);
  tableBody.innerHTML='';
  for(const p of rows) addRow(p.x,p.z, p.tag||'', Number.isFinite(p.n)?p.n:'');
  ensureTrailingBlankRow();
  clearCellSelection();
  compute();
}

/* ======= Selection model ======= */
let selectedCells=new Set();
let suppressNextClick=false;
let isDragging=false;
let dragMode=null; // 'rows' | 'cells'

function isCellVisible(td){
  if(!td) return false;
  const cs = window.getComputedStyle(td);
  return cs.display !== 'none' && cs.visibility !== 'hidden';
}
function isEditableCell(td){
  return !!td && (td.classList.contains('cell-station') || td.classList.contains('cell-elev') || td.classList.contains('cell-n')) && isCellVisible(td);
}
function editableCellsInRow(tr){
  const tds = [
    tr.querySelector('td.cell-station'),
    tr.querySelector('td.cell-elev'),
    tr.querySelector('td.cell-n')
  ].filter(isEditableCell);
  return tds;
}
function cellColIndex(td){
  if(!td) return -1;
  const tr = td.closest('tr');
  if(!tr) return -1;
  const cols = editableCellsInRow(tr);
  return cols.indexOf(td);
}
function getCellByRowCol(rowIdx, colIdx){
  const rows = getRows();
  if(rowIdx < 0 || rowIdx >= rows.length) return null;
  const cols = editableCellsInRow(rows[rowIdx]);
  if(colIdx < 0 || colIdx >= cols.length) return null;
  return cols[colIdx];
}
function clearCellSelection(){
  // Changing selection stops editing.
  stopEditingActiveInput();
  selectedCells.forEach(td=>td.classList.remove('cell-selected'));
  selectedCells.clear();
}
function addCellToSelection(td){
  if(!td) return;
  if(!(td.classList.contains('cell-station')||td.classList.contains('cell-elev')||td.classList.contains('cell-n'))) return;
  if(!selectedCells.has(td)){
    selectedCells.add(td);
    td.classList.add('cell-selected');
  }
}
function addRowCellsToSelection(tr){
  addCellToSelection(tr.querySelector('td.cell-station'));
  addCellToSelection(tr.querySelector('td.cell-elev'));
  addCellToSelection(tr.querySelector('td.cell-n'));
}
function firstSelectedRow(){
  if(!selectedCells.size) return null;
  const rows=getRows();
  let min=Infinity,row=null;
  selectedCells.forEach(td=>{
    const r=td.closest('tr');
    const idx=rows.indexOf(r);
    if(idx>=0 && idx<min){min=idx;row=r;}
  });
  return row;
}
function firstSelectedCell(){
  if(!selectedCells.size) return null;
  const rows = getRows();
  const candidates = [...selectedCells].filter(isEditableCell).map(td=>{
    const r = td.closest('tr');
    const rIdx = rows.indexOf(r);
    const cIdx = cellColIndex(td);
    return {td, rIdx, cIdx};
  }).filter(o=>o.rIdx>=0 && o.cIdx>=0);
  if(!candidates.length){
    const r = firstSelectedRow();
    if(!r) return null;
    const cols = editableCellsInRow(r);
    return cols[0] || null;
  }
  candidates.sort((a,b)=> (a.rIdx - b.rIdx) || (a.cIdx - b.cIdx));
  return candidates[0].td;
}
function singleSelectedCell(){
  if(selectedCells.size !== 1) return null;
  const td = [...selectedCells][0];
  return isEditableCell(td) ? td : null;
}
function selectSingleCell(td){
  if(!td) return;
  clearCellSelection();
  addCellToSelection(td);
}

function getActiveEditingInput(){
  const el = document.activeElement;
  if(el && el.tagName === 'INPUT' && el.closest('#xsTable')) return el;
  return null;
}
function stopEditingActiveInput(){
  const active = getActiveEditingInput();
  if(active) active.blur();
}

// Ensure the grid (table) has focus so document-level key handlers work
function focusGrid(){
  const t=document.getElementById('xsTable');
  if(t && typeof t.focus==='function'){
    try{ t.focus({preventScroll:true}); }catch(_){ t.focus(); }
  }
}

function neighborCell(baseTd, dir){
  if(!isEditableCell(baseTd)) return null;
  const rIdx = rowIndexOf(baseTd.closest('tr'));
  const cIdx = cellColIndex(baseTd);
  if(rIdx < 0 || cIdx < 0) return null;
  let nr = rIdx, nc = cIdx;
  if(dir==='up'){ nr = rIdx-1; }
  else if(dir==='down'){ nr = rIdx+1; }
  else if(dir==='left'){ nc = cIdx-1; }
  else if(dir==='right'){ nc = cIdx+1; }
  if(dir==='down'){ ensureTrailingBlankRow(); }
  return getCellByRowCol(nr, nc) || null;
}

function isPrintableNumeric(e){
  if(e.ctrlKey || e.metaKey || e.altKey) return false;
  if(e.key.length !== 1) return false;
  return /[0-9eE\.\-\+]/.test(e.key);
}

function startEditingWithChar(ch){
  const td = singleSelectedCell();
  if(!td) return;
  const inp = td.querySelector('input'); if(!inp) return;
  inp.focus();
  const cur = String(inp.value ?? '');
  const next = cur + ch;
  inp.value = next;
  try{ const L = next.length; inp.setSelectionRange(L, L); }catch(_){}
  inp.dispatchEvent(new Event('input', {bubbles:true}));
}
function startEditingWithBackspace(){
  const td = singleSelectedCell();
  if(!td) return;
  const inp = td.querySelector('input'); if(!inp) return;
  inp.focus();
  let cur = String(inp.value ?? '');
  if(cur.length > 0) cur = cur.slice(0, -1);
  inp.value = cur;
  try{ const L = cur.length; inp.setSelectionRange(L, L); }catch(_){}
  inp.dispatchEvent(new Event('input', {bubbles:true}));
}

/* Drag/click selection */
tableBody.addEventListener('mousedown',(e)=>{
  stopEditingActiveInput();
  const td=e.target.closest('td');
  if(!td) return;
  if(td.classList.contains('cell-id')){
    e.preventDefault();
    if(!(e.ctrlKey||e.metaKey||e.shiftKey)) clearCellSelection();
    addRowCellsToSelection(td.closest('tr'));
    focusGrid();
    isDragging=true; dragMode='rows'; suppressNextClick=true; return;
  }
  if(isEditableCell(td)){
    e.preventDefault();
    if(!(e.ctrlKey||e.metaKey||e.shiftKey)) clearCellSelection();
    addCellToSelection(td);
    focusGrid();
    isDragging=true; dragMode='cells'; suppressNextClick=true; return;
  }
});
tableBody.addEventListener('mousemove',(e)=>{
  if(!isDragging) return;
  const td=e.target.closest('td'); if(!td) return;
  if(dragMode==='rows'){
    const tr=td.closest('tr'); if(tr) addRowCellsToSelection(tr);
  }else if(dragMode==='cells'){
    if(isEditableCell(td)) addCellToSelection(td);
  }
});
document.addEventListener('mouseup',()=>{
  if(isDragging){ isDragging=false; dragMode=null; suppressNextClick=true; }
});
tableBody.addEventListener('click',(e)=>{
  if(suppressNextClick){ suppressNextClick=false; return; }
  const td=e.target.closest('td'); if(!td) return;
  stopEditingActiveInput();
  if(td.classList.contains('cell-id')){
    clearCellSelection(); addRowCellsToSelection(td.closest('tr')); focusGrid(); return;
  }
  if(isEditableCell(td)){
    clearCellSelection(); addCellToSelection(td); focusGrid(); return;
  }
});
tableBody.addEventListener('dblclick',(e)=>{
  const td=e.target.closest('td'); if(!td) return;
  if(isEditableCell(td)){ selectSingleCell(td); }
  if(td.querySelector('input')){
    const inp=td.querySelector('input'); inp.focus();
    try{ const L=String(inp.value).length; inp.setSelectionRange(L,L);}catch(_){}
  }
});
tableBody.addEventListener('focusin',(e)=>{
  const td = e.target.closest('td');
  if(isEditableCell(td)){
    if(!(selectedCells.size===1 && selectedCells.has(td))){
      clearCellSelection(); addCellToSelection(td);
    }
  }
});

/* ---- FIX: Enter while editing should blur & keep selection (no movement) ---- */
tableBody.addEventListener('keydown',(e)=>{
  if(e.key==='Enter' && e.target && e.target.tagName==='INPUT'){
    e.preventDefault();            // do not submit / insert newline
    e.stopPropagation();           // keep from reaching document handler
    const td = e.target.closest('td');
    if(isEditableCell(td)){
      if(!(selectedCells.size===1 && selectedCells.has(td))){
        selectSingleCell(td);      // ensure the same cell stays selected
      }
    }
    e.target.blur();               // stop editing
  }
});

/* Delete/clear helpers */
function clearSelectedCells(){
  if(selectedCells.size===0) return;
  selectedCells.forEach(td=>{
    const inp=td.querySelector('input');
    if(inp) inp.value='';
  });
  ensureTrailingBlankRow();
  compute();
}
function deleteRowsWithSelectedCells(){
  const sel=[...tableBody.querySelectorAll('td.cell-selected')];
  if(!sel.length) return;
  const del=new Set(sel.map(td=>td.closest('tr')));
  del.forEach(r=>r.remove());
  renumberIDs(); ensureTrailingBlankRow(); clearCellSelection(); compute();
}

/* Inputs -> compute */
tableBody.addEventListener('change',(e)=>{
  const t=e.target;
  if(t && (t.classList.contains('stagetag') || t.classList.contains('nval') || t.classList.contains('station') || t.classList.contains('elevation'))){
    if(t.classList.contains('stagetag')) enforceUniqueStageTag(t);
    compute();
  }
});
tableBody.addEventListener('input',(e)=>{
  const t=e.target;
  if(t && (t.classList.contains('station')||t.classList.contains('elevation')||t.classList.contains('nval'))){
    const tr=t.closest('tr');
    if(isLastRow(tr)){
      const s=tr.querySelector('.station').value, z=tr.querySelector('.elevation').value;
      if(s!==''||z!=='') ensureTrailingBlankRow();
    }
    compute();
  }
});
tableBody.addEventListener('keyup',(e)=>{
  const t=e.target;
  if(t && (t.classList.contains('nval')||t.classList.contains('station')||t.classList.contains('elevation'))) compute();
});

/* ---- Keyboard (global) ---- */
document.addEventListener('keydown',(e)=>{
  // If some inner handler already prevented default, do nothing
  if (e.defaultPrevented) return;

  const activeInput = getActiveEditingInput();

  // Delete clears selected cells only when NOT editing
  if(e.key === 'Delete' && !activeInput && selectedCells.size>0){
    e.preventDefault();
    clearSelectedCells();
    return;
  }

  // If editing, let normal typing/arrows work (Enter handled on input)
  if(activeInput){ return; }

  // Arrow navigation from first selected cell (range or single)
  const dirMap = { ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right' };
  if(dirMap[e.key]){
    if(selectedCells.size>0){
      e.preventDefault();
      const base = firstSelectedCell();
      if(base){
        const next = neighborCell(base, dirMap[e.key]);
        if(next){ selectSingleCell(next); }
      }
    }
    return;
  }

  // Enter when not editing: move to "next cell" (down)
  if(e.key === 'Enter'){
    if(selectedCells.size>0){
      e.preventDefault();
      const base = firstSelectedCell();
      if(base){
        ensureTrailingBlankRow();
        const next = neighborCell(base, 'down') || base;
        selectSingleCell(next);
      }
    }
    return;
  }

  // ---- Backspace when not editing: start editing, delete last character ----
  if(e.key === 'Backspace'){
    if(selectedCells.size===1 && isEditableCell([...selectedCells][0])){
      e.preventDefault(); // avoid navigating back
      startEditingWithBackspace();
    }
    return;
  }

  // Type-to-edit: when exactly one cell is selected and not editing
  if(selectedCells.size===1 && isEditableCell([...selectedCells][0]) && isPrintableNumeric(e)){
    e.preventDefault();
    startEditingWithChar(e.key);
    return;
  }
});

document.addEventListener('mousedown',(e)=>{
  const inCells=e.target.closest('#xsTable td.cell-id, #xsTable td.cell-station, #xsTable td.cell-elev, #xsTable td.cell-n');
  const onToolbar=e.target.closest('.actions')||e.target.closest('.actions-xs');
  if(!inCells && !onToolbar){
    clearCellSelection();
  }
});

/* Action buttons */
function flashButton(btn){ btn.classList.add('clicked'); setTimeout(()=>btn.classList.remove('clicked'),160); }
document.getElementById('insertRow').addEventListener('click',(e)=>{
  flashButton(e.currentTarget);
  if(selectedCells.size===0) return;
  const target=firstSelectedRow();
  if(target){
    addRow('','','','',target);
    ensureTrailingBlankRow();
    clearCellSelection();
    compute();
  }
});
document.getElementById('deleteSelected').addEventListener('click',(e)=>{
  flashButton(e.currentTarget);
  if(selectedCells.size===0) return;
  deleteRowsWithSelectedCells();
});
document.getElementById('sortBtn').addEventListener('click',(e)=>{
  flashButton(e.currentTarget);
  sortTable();
});
document.getElementById('resetExample').addEventListener('click',(e)=>{
  flashButton(e.currentTarget);
  resetExample();
});

/* Controls that trigger recompute */
['units','slope','depth','discharge','nLOB','nMC','nROB'].forEach(id=>{
  const el=document.getElementById(id);
  el.addEventListener(id==='units'?'change':'input', compute);
});
['N_LOB','N_CHAN','N_ROB'].forEach(id=>{
  const el=document.getElementById(id);
  el.addEventListener('change', ()=>{
    updateSliceOptionStates();
    compute();
  });
});
['pmOff','pmXS','pmSlices'].forEach(id=>{
  const el=document.getElementById(id);
  el.addEventListener('change', compute);
});

/* Slice selects */
function fillSliceSelect(sel,def=1){
  sel.innerHTML='';
  for(let i=1;i<=45;i++){
    const o=document.createElement('option');
    o.value=String(i); o.textContent=String(i);
    sel.appendChild(o);
  }
  sel.value=String(def);
}
function updateSliceOptionStates(){
  const sLOB=document.getElementById('N_LOB');
  const sCH =document.getElementById('N_CHAN');
  const sROB=document.getElementById('N_ROB');
  let changed=true, guard=0;
  while(changed && guard<6){
    guard++; changed=false;
    const vLOB=parseInt(sLOB.value||'1',10);
    const vCH =parseInt(sCH.value ||'1',10);
    const vROB=parseInt(sROB.value||'1',10);
    function capOptions(sel,cur,others){
      const max=Math.max(1,45-others);
      [...sel.options].forEach(o=>{
        const v=parseInt(o.value,10);
        o.disabled=(v>max);
        o.style.color=o.disabled?'#aaa':'';
      });
      if(cur>max){ sel.value=String(max); changed=true; }
    }
    capOptions(sLOB, vLOB, vCH+vROB);
    capOptions(sCH, vCH, vLOB+vROB);
    capOptions(sROB, vROB, vLOB+vCH);
  }
}

/* Harmonize widths of some buttons */
function harmonizeButtons(){
  const btns=[document.getElementById('resetExample'), document.getElementById('sortBtn'), document.getElementById('deleteSelected')].filter(Boolean);
  if(!btns.length) return;
  btns.forEach(b=>b.style.width='auto');
  const max=Math.max(...btns.map(b=>b.getBoundingClientRect().width));
  btns.forEach(b=>b.style.width=Math.ceil(max)+'px');
}
window.addEventListener('load', harmonizeButtons);
window.addEventListener('resize', harmonizeButtons);

/* HVn toggle UI */
const hvnToggle=document.getElementById('hvnToggle');
hvnToggle.addEventListener('change', ()=> updateHVnUI(hvnToggle.checked));
function updateHVnUI(on){
  document.body.classList.toggle('hvn-on', on);
  const inputs=['nLOB','nMC','nROB'].map(id=>document.getElementById(id));
  inputs.forEach(inp=>{
    inp.disabled=on;
    inp.title = on ? 'Disabled when Horizontal Variation of n is ON' : '';
  });
  const msgEl=document.getElementById('messages');
  if(on){
    msgEl.textContent='HVn is ON: LOB/Channel/ROB n inputs and n‑picker won’t affect results. Edit n in the Cross‑Section table.';
  }else{
    msgEl.textContent='';
  }
  compute();
}

/* Specify Discharge UI */
const specifyQEl = document.getElementById('specifyQ');
specifyQEl.addEventListener('change', ()=> updateQModeUI(specifyQEl.checked));
function updateQModeUI(on){
  const depthEl = document.getElementById('depth');
  const qEl = document.getElementById('discharge');
  if(on){
    depthEl.disabled = true; depthEl.title = 'Disabled when Specify Discharge is ON';
    qEl.disabled = false; qEl.title = '';
  }else{
    depthEl.disabled = false; depthEl.title = '';
    qEl.disabled = true; qEl.title = 'Disabled when Specify Discharge is OFF';
  }
  compute();
}

/* ===================== HCS STATE ===================== */
let ineffectiveAreas = [];
let obstructions = [];
let levees = { left: {enabled:false, station:null, crest:null}, right: {enabled:false, station:null, crest:null} };

function renderIFATable(){
  const tbody=document.querySelector('#ifaTable tbody');
  tbody.innerHTML='';
  ineffectiveAreas.forEach((row,idx)=>{
    const tr=document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="any" class="ifa-l" value="${row.l??''}"></td>
      <td><input type="number" step="any" class="ifa-r" value="${row.r??''}"></td>
      <td><input type="number" step="any" class="ifa-e" value="${row.elev??''}"></td>
      <td style="text-align:center"><input type="checkbox" class="ifa-p" ${row.permanent?'checked':''}></td>
      <td class="actCol" style="text-align:center"><button class="btnDel" title="Delete">Del</button></td>
    `;
    tbody.appendChild(tr);
    tr.querySelector('.ifa-l').addEventListener('input', e=>{ row.l=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.ifa-r').addEventListener('input', e=>{ row.r=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.ifa-e').addEventListener('input', e=>{ row.elev=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.ifa-p').addEventListener('change', e=>{ row.permanent=!!e.target.checked; compute(); });
    tr.querySelector('.btnDel').addEventListener('click', ()=>{ ineffectiveAreas.splice(idx,1); renderIFATable(); compute(); });
  });
}
document.getElementById('addIFA').addEventListener('click', ()=>{
  ineffectiveAreas.push({l:null,r:null,elev:null,permanent:false});
  renderIFATable();
});

function renderObsTable(){
  const tbody=document.querySelector('#obsTable tbody');
  tbody.innerHTML='';
  obstructions.forEach((row,idx)=>{
    const tr=document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="any" class="ob-l" value="${row.l??''}"></td>
      <td><input type="number" step="any" class="ob-r" value="${row.r??''}"></td>
      <td><input type="number" step="any" class="ob-t" value="${row.top??''}"></td>
      <td class="actCol" style="text-align:center"><button class="btnDel" title="Delete">Del</button></td>
    `;
    tbody.appendChild(tr);
    tr.querySelector('.ob-l').addEventListener('input', e=>{ row.l=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.ob-r').addEventListener('input', e=>{ row.r=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.ob-t').addEventListener('input', e=>{ row.top=parseFloatOrNull(e.target.value); compute(); });
    tr.querySelector('.btnDel').addEventListener('click', ()=>{ obstructions.splice(idx,1); renderObsTable(); compute(); });
  });
}
document.getElementById('addOBS').addEventListener('click', ()=>{
  obstructions.push({l:null,r:null,top:null});
  renderObsTable();
});

function renderLevTable(){
  const tbl=document.getElementById('levTable');
  ['left','right'].forEach(side=>{
    const tr = tbl.querySelector(`tr[data-side="${side}"]`);
    if(!tr) return;
    const en=tr.querySelector('.lev-en');
    const st=tr.querySelector('.lev-sta');
    const cr=tr.querySelector('.lev-crest');
    en.checked = !!levees[side].enabled;
    st.value = levees[side].station ?? '';
    cr.value = levees[side].crest ?? '';
    en.onchange = ()=>{ levees[side].enabled = !!en.checked; compute(); };
    st.oninput = ()=>{ levees[side].station = parseFloatOrNull(st.value); compute(); };
    cr.oninput = ()=>{ levees[side].crest = parseFloatOrNull(cr.value); compute(); };
  });
}

/* Tabs */
document.querySelectorAll('.tab').forEach(tab=>{
  tab.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tabPanel').forEach(p=>p.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById('tab-'+tab.dataset.tab).classList.add('active');
  });
});

/* ===================== DESIGNER INTEGRATION ===================== */
(function(){
  const autoToggleId = 'designerAutoApply';
  const applyBtnId = 'designerApply';

  function nval(id){
    const el = document.getElementById(id);
    if(!el) return null;
    const v = parseFloat(el.value);
    return Number.isFinite(v) ? v : null;
  }
  function bool(id){
    const el = document.getElementById(id);
    return !!(el && el.checked);
  }
  function intval(id, def){
    const el = document.getElementById(id);
    if(!el) return def;
    const v = parseInt(el.value,10);
    return Number.isFinite(v) ? v : def;
  }
  function setDisabled(ids, dis){ ids.forEach(id=>{ const el=document.getElementById(id); if(el) el.disabled = !!dis; }); }

  function setDesignerEnableStates(){
    const nStages = intval('des-numStages', 1);
    const ibOn = bool('des-isInnerBerm');
    // Stage 2
    const s2 = [
      'des-s2-D2stg','des-s2-Mbanks_2stg','des-s2-Wbench_L','des-s2-Wbench_R',
      'des-s2-Ybench_L','des-s2-Ybench_R','des-s2-Mtieout_2stg_L','des-s2-Mtieout_2stg_R'
    ];
    // Stage 3
    const s3 = [
      'des-s3-D3stg','des-s3-Mbanks_3stg','des-s3-W3rdstage_L','des-s3-W3rdstage_R',
      'des-s3-y3rdStage_L','des-s3-y3rdStage_R','des-s3-Mtieout_3stg_L','des-s3-Mtieout_3stg_R'
    ];
    // Inner Berm
    const ib = ['des-ib-WIB','des-ib-DmaxIB'];
    setDisabled(s2, nStages<2);
    setDisabled(s3, nStages<3);
    setDisabled(ib, !ibOn);
  }

  function getDesignerParamsFromUI(){
    return {
      numStages: intval('des-numStages', 1),
      unitSystem: (document.getElementById('units')?.value || 'US'),
      isInnerBerm: bool('des-isInnerBerm'),
      stage1: {
        Width: nval('des-s1-Width'),
        Depth: nval('des-s1-Depth'),
        mbanks: nval('des-s1-mbanks'),
        ybed: nval('des-s1-ybed'),
        thalweg_shift: nval('des-s1-thalweg_shift'),
        Mtieout_L: nval('des-s1-Mtieout_L'),
        Mtieout_R: nval('des-s1-Mtieout_R'),
        Roundness: nval('des-s1-Roundness')
      },
      stage2: {
        D2stg: nval('des-s2-D2stg'),
        Mbanks_2stg: nval('des-s2-Mbanks_2stg'),
        Wbench_L: nval('des-s2-Wbench_L'),
        Wbench_R: nval('des-s2-Wbench_R'),
        Ybench_L: nval('des-s2-Ybench_L'),
        Ybench_R: nval('des-s2-Ybench_R'),
        Mtieout_2stg_L: nval('des-s2-Mtieout_2stg_L'),
        Mtieout_2stg_R: nval('des-s2-Mtieout_2stg_R')
      },
      stage3: {
        D3stg: nval('des-s3-D3stg'),
        Mbanks_3stg: nval('des-s3-Mbanks_3stg'),
        W3rdstage_L: nval('des-s3-W3rdstage_L'),
        W3rdstage_R: nval('des-s3-W3rdstage_R'),
        y3rdStage_L: nval('des-s3-y3rdStage_L'),
        y3rdStage_R: nval('des-s3-y3rdStage_R'),
        Mtieout_3stg_L: nval('des-s3-Mtieout_3stg_L'),
        Mtieout_3stg_R: nval('des-s3-Mtieout_3stg_R')
      },
      innerBerm: {
        WIB: nval('des-ib-WIB'),
        DmaxIB: nval('des-ib-DmaxIB')
      },
      advanced: {
        Left_BKF_Height_Multiplier: nval('des-adv-Left_BKF_Height_Multiplier'),
        Right_BKF_Height_Multiplier: nval('des-adv-Right_BKF_Height_Multiplier'),
        Left_Mbanks_BKF_Multiplier: nval('des-adv-Left_Mbanks_BKF_Multiplier'),
        Right_Mbanks_BKF_Multiplier: nval('des-adv-Right_Mbanks_BKF_Multiplier'),
        Left_BKF_Bottom_Slope_Multiplier: nval('des-adv-Left_BKF_Bottom_Slope_Multiplier'),
        Right_BKF_Bottom_Slope_Multiplier: nval('des-adv-Right_BKF_Bottom_Slope_Multiplier'),
        X_datum: nval('des-adv-X_datum'),
        Y_datum: nval('des-adv-Y_datum')
      }
    };
  }

  function fmt3(x){ return Number.isFinite(+x) ? (+x).toFixed(3) : ''; }

  function applyDesignerRowsToXsTable(rows){
    try{
      if(!Array.isArray(rows) || !rows.length) return;
      const tbody = document.querySelector('#xsTable tbody');
      if(!tbody) return;
      tbody.innerHTML='';
      for(const r of rows){
        const st = (r && typeof r.station!== 'undefined') ? r.station : null;
        const el = (r && typeof r.elevation!== 'undefined') ? r.elevation : null;
        // Map point names to stage tags for our table: L5 => LB, R5 => RB
        let tag = '';
        if(r && typeof r.name === 'string'){
          if(r.name === 'L5') tag = 'LB';
          else if(r.name === 'R5') tag = 'RB';
        }
        addRow(fmt3(st), fmt3(el), tag, '');
      }
      ensureTrailingBlankRow();
      clearCellSelection();
      compute();
      updateXsLockFromAutoToggle();
    }catch(e){ /* silently ignore UI message; may log if needed */ }
  }

  function hasCalc(){ return typeof window.calculateCrossSection === 'function'; }

  function runDesignerApply(){
    if(!hasCalc()){
      // Calculator not present; skip without UI message
      return;
    }
    setDesignerEnableStates();
    const params = getDesignerParamsFromUI();
    try{
      const rows = window.calculateCrossSection(params);
      if(!Array.isArray(rows)) return;
      applyDesignerRowsToXsTable(rows);
    }catch(err){
      // Swallow UI message; optional: console.warn('Designer apply error', err);
    }
  }

  function maybeAuto(){
    const auto = document.getElementById(autoToggleId);
    if(auto && auto.checked) runDesignerApply();
  }

  function wireDesigner(){
    setDesignerEnableStates();
    // Keep unit labels in sync with Setup -> Unit system
    function updateUnitTags(){
      const sys = document.getElementById('units')?.value || 'US';
      const len = sys === 'SI' ? '(m)' : '(ft)';
      const slope = sys === 'SI' ? '(m/m)' : '(ft/ft)';
      const q = sys === 'SI' ? '(m³/s)' : '(ft³/s)';
      document.querySelectorAll('.unit-len').forEach(el=>{ el.textContent = len; });
      document.querySelectorAll('.unit-slope').forEach(el=>{ el.textContent = slope; });
      document.querySelectorAll('.unit-q').forEach(el=>{ el.textContent = q; });
    }
    updateUnitTags();
    const unitsSel = document.getElementById('units');
    if(unitsSel){ unitsSel.addEventListener('change', updateUnitTags); }
    const applyBtn = document.getElementById(applyBtnId);
    if(applyBtn){
      applyBtn.addEventListener('click', (e)=>{
        e.currentTarget.classList.add('clicked');
        setTimeout(()=>e.currentTarget.classList.remove('clicked'),160);
        runDesignerApply();
      });
    }
    const auto = document.getElementById(autoToggleId);
    if(auto){
      auto.addEventListener('change', ()=>{
        updateXsLockFromAutoToggle();
        if(auto.checked) runDesignerApply();
      });
    }
    // Recompute on any change within the Designer panel
    const panel = document.getElementById('tab-designer');
    if(panel){
      panel.querySelectorAll('input,select').forEach(el=>{
        el.addEventListener('input', ()=>{ setDesignerEnableStates(); maybeAuto(); });
        el.addEventListener('change', ()=>{ setDesignerEnableStates(); maybeAuto(); });
      });
    }
    // Locking reacts to HVn changes
    const hvn = document.getElementById('hvnToggle');
    if(hvn){ hvn.addEventListener('change', updateXsLockFromAutoToggle); }

    // No status message
    // Initial lock state sync
    updateXsLockFromAutoToggle();
  }

  // Wire up after DOM is parsed
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wireDesigner);
  else wireDesigner();
})();

// Table lock/unlock when Designer auto-apply is ON
function updateXsLockFromAutoToggle(){
  const auto = document.getElementById('designerAutoApply');
  const lock = !!(auto && auto.checked);
  const hvnOn = !!document.getElementById('hvnToggle')?.checked;
  const tbody = document.querySelector('#xsTable tbody');
  if(tbody){
    tbody.querySelectorAll('tr').forEach(tr=>{
      const st = tr.querySelector('input.station');
      const el = tr.querySelector('input.elevation');
      const tg = tr.querySelector('select.stagetag');
      const nv = tr.querySelector('input.nval');
      if(st) st.disabled = lock;
      if(el) el.disabled = lock;
      if(tg) tg.disabled = lock;
      if(nv) nv.disabled = !hvnOn; // enable only when Horizontal Variation of n is ON
    });
  }
  // Disable table action buttons under lock
  const ins = document.getElementById('insertRow');
  const del = document.getElementById('deleteSelected');
  const srt = document.getElementById('sortBtn');
  if(ins) ins.disabled = lock;
  if(del) del.disabled = lock;
  if(srt) srt.disabled = lock;
}

/* ===================== GEOMETRY & HYDRAULICS ===================== */
/* (The hydraulics engine below is unchanged except for cosmetic plotting tweaks) */

function parseFloatOrNull(v){ const x=parseFloat(v); return Number.isFinite(x)?x:null; }

function polylineBetween(pts,xA,xB){
  const seg=[];
  for(let i=0;i<pts.length-1;i++){
    const {x:x1,z:z1}=pts[i], {x:x2,z:z2}=pts[i+1];
    if(x2<=xA||x1>=xB) continue;
    const xa=Math.max(x1,xA), xb=Math.min(x2,xB);
    const dx=x2-x1; const m=(z2-z1)/dx;
    const za=z1+m*(xa-x1), zb=z1+m*(xb-x1);
    if(!seg.length) seg.push({x:xa,z:za});
    if(x1>xa&&x1<xb) seg.push({x:x1,z:z1});
    if(x2>xa&&x2<xb) seg.push({x:x2,z:z2});
    seg.push({x:xb,z:zb});
  }
  const out=[];
  for(const p of seg){
    if(!out.length||Math.abs(out[out.length-1].x-p.x)>1e-12) out.push(p);
    else out[out.length-1]=p;
  }
  return out;
}
function integrateOnPolyline(polyPts,stage){
  let A=0,P=0;
  const intervals=[];
  for(let i=0;i<polyPts.length-1;i++){
    const p1=polyPts[i], p2=polyPts[i+1];
    const x1=p1.x, z1=p1.z, x2=p2.x, z2=p2.z;
    const dx=x2-x1; if(dx<=0) continue;
    const rel1=z1-stage, rel2=z2-stage;
    const m=(z2-z1)/dx;
    if(rel1<=0 && rel2<=0){
      const d1=-rel1,d2=-rel2; A+=0.5*(d1+d2)*dx; P+=Math.hypot(dx,z2-z1); intervals.push([x1,x2]);
    }else if((rel1<=0&&rel2>0)||(rel1>0&&rel2<=0)){
      const t=(stage - z1)/(z2 - z1); const xi=x1 + t*dx; const slopeLen=Math.sqrt(1+m*m);
      if(rel1<=0&&rel2>0){ const dxw=xi-x1, d1=-rel1; A+=0.5*d1*Math.abs(dxw); P+=slopeLen*Math.abs(dxw); intervals.push([x1,xi]); }
      else { const dxw=x2-xi, d2=-rel2; A+=0.5*d2*Math.abs(dxw); P+=slopeLen*Math.abs(dxw); intervals.push([xi,x2]); }
    }
  }
  intervals.sort((a,b)=>a[0]-b[0]);
  const merged=[]; const eps=1e-12;
  for(const [a,b] of intervals){
    if(!merged.length) merged.push([a,b]);
    else { const L=merged[merged.length-1]; if(a<=L[1]+eps) L[1]=Math.max(L[1],b); else merged.push([a,b]); }
  }
  let T=0; for(const [a,b] of merged) T+=(b-a);
  return {A,P,T,wetIntervals:merged};
}
function integrateSectionInRangeOnBed(bedPts,stage,xL,xR){
  if(!(xR>xL)) return {A:0,P:0,T:0,wetIntervals:[]};
  const seg=polylineBetween(bedPts, xL, xR);
  if(seg.length<2) return {A:0,P:0,T:0,wetIntervals:[]};
  return integrateOnPolyline(seg,stage);
}
function totalWetWidth(intervals){ return intervals.reduce((s,[a,b])=>s+(b-a),0); }

/* HVn helpers */
function buildNSegments(rows){
  const rowsSorted = rows.slice().sort((a,b)=>a.x-b.x);
  if(!rowsSorted.length) return {ok:false, err:'No rows', segments:[]};
  const firstN = rowsSorted[0].n;
  if(!Number.isFinite(firstN)) return {ok:false, err:'HVn is ON: first (leftmost) row must have an n value.', segments:[]};
  const segments=[]; let currentN=firstN;
  for(let i=0;i<rowsSorted.length-1;i++){
    const a=rowsSorted[i], b=rowsSorted[i+1];
    segments.push({xL:a.x, xR:b.x, n:currentN});
    if(Number.isFinite(b.n)) currentN=b.n;
  }
  return {ok:true, segments};
}
function clipSegments(segments, L, R){
  const out=[];
  for(const s of segments){
    const xL=Math.max(L, s.xL), xR=Math.min(R, s.xR);
    if(xR>xL) out.push({xL, xR, n:s.n});
  }
  return out;
}
function bankSlopeRatios(pts, LBx, RBx){
  const idxLB = pts.findIndex(p=>p.x===LBx);
  const idxRB = pts.findIndex(p=>p.x===RBx);
  let SL=Infinity, SR=Infinity;
  if(idxLB>=0 && idxLB+1<pts.length){
    const dx=pts[idxLB+1].x - pts[idxLB].x; const dz=pts[idxLB+1].z - pts[idxLB].z;
    SL = (Math.abs(dz)>0)? Math.abs(dx/dz) : Infinity;
  }
  if(idxRB-1>=0 && idxRB<pts.length){
    const dx=pts[idxRB].x - pts[idxRB-1].x; const dz=pts[idxRB].z - pts[idxRB-1].z;
    SR = (Math.abs(dz)>0)? Math.abs(dx/dz) : Infinity;
  }
  return {SL, SR};
}
function buildPlotNSegmentsFromExplicit(rowsSorted, leftX, rightX){
  const explicit = rowsSorted
    .filter(r => Number.isFinite(r.n))
    .map(r => ({ x: r.x, n: r.n }));
  if (!explicit.length) return [];
  explicit.sort((a,b)=>a.x-b.x);
  const segs = [];
  let curX = explicit[0].x;
  let curN = explicit[0].n;
  for (let i=1; i<explicit.length; i++){
    const e = explicit[i];
    if (Math.abs(e.n - curN) > 1e-12) {
      segs.push({ xL: curX, xR: e.x, n: curN });
      curX = e.x; curN = e.n;
    }
  }
  segs.push({ xL: curX, xR: rightX, n: curN });
  if (explicit[0].x > leftX) segs.unshift({ xL: leftX, xR: explicit[0].x, n: explicit[0].n });
  return segs
    .map(s => ({ xL: Math.max(leftX, s.xL), xR: Math.min(rightX, s.xR), n: s.n }))
    .filter(s => s.xR > s.xL + 1e-9);
}

/* HCS → effective bed and levees */
function floorAtX(x, stage){
  let f = -Infinity;
  for(const ob of obstructions){
    if(ob && Number.isFinite(ob.l) && Number.isFinite(ob.r) && Number.isFinite(ob.top) && ob.r>ob.l){
      if(x>=Math.min(ob.l,ob.r) && x<=Math.max(ob.l,ob.r)) f = Math.max(f, ob.top);
    }
  }
  for(const ia of ineffectiveAreas){
    if(!ia || !Number.isFinite(ia.l) || !Number.isFinite(ia.r) || !Number.isFinite(ia.elev)) continue;
    const xl=Math.min(ia.l, ia.r), xr=Math.max(ia.l, ia.r);
    if(x>=xl && x<=xr){
      if(ia.permanent || stage <= ia.elev){ f = Math.max(f, ia.elev); }
    }
  }
  return f;
}
function buildConveyanceBed(bedPts, stage){
  const xs = bedPts.map(p=>p.x);
  const xMin = Math.min(...xs), xMax=Math.max(...xs);
  const cuts = new Set(xs);
  for(const ob of obstructions){ if(!ob) continue; if(Number.isFinite(ob.l)) cuts.add(ob.l); if(Number.isFinite(ob.r)) cuts.add(ob.r); }
  for(const ia of ineffectiveAreas){ if(!ia) continue; if(Number.isFinite(ia.l)) cuts.add(ia.l); if(Number.isFinite(ia.r)) cuts.add(ia.r); }
  const X=[...cuts].sort((a,b)=>a-b);
  const eff=[];
  const pushPt=(x,z)=>{ if(!eff.length || Math.abs(eff[eff.length-1].x - x) > 1e-12 || Math.abs(eff[eff.length-1].z - z) > 1e-12){ eff.push({x,z}); } };
  for(let i=0;i<X.length-1;i++){
    const xa=X[i], xb=X[i+1]; if(!(xb>xa)) continue;
    const seg=polylineBetween(bedPts, xa, xb); if(seg.length<2) continue;
    const F = floorAtX(0.5*(xa+xb), stage);
    for(let j=0;j<seg.length-1;j++){
      const p1=seg[j], p2=seg[j+1]; const x1=p1.x, z1=p1.z, x2=p2.x, z2=p2.z; if(!(x2>x1)) continue;
      const m=(z2-z1)/(x2-x1);
      const z1c = Math.max(z1, F), z2c=Math.max(z2, F);
      if(z1>=F && z2>=F){ if(!eff.length) pushPt(x1,z1c); pushPt(x2,z2c); }
      else if(z1<=F && z2<=F){ if(!eff.length) pushPt(x1,F); pushPt(x2,F); }
      else{
        const xi = x1 + (F - z1)/m;
        if(z1<F && z2>F){ if(!eff.length) pushPt(x1,F); pushPt(xi,F); pushPt(x2,z2); }
        else{ if(!eff.length) pushPt(x1,z1); pushPt(xi,F); pushPt(x2,F); }
      }
    }
  }
  if(!eff.length){
    const seg=polylineBetween(bedPts, xMin, xMax);
    return seg.length? seg : bedPts.slice();
  }
  return eff;
}
function leveeClip(stage, xMin, xMax){
  let L = xMin, R = xMax;
  if(levees.left.enabled && Number.isFinite(levees.left.station) && Number.isFinite(levees.left.crest) && stage < levees.left.crest){ L = Math.max(L, levees.left.station); }
  if(levees.right.enabled && Number.isFinite(levees.right.station) && Number.isFinite(levees.right.crest) && stage < levees.right.crest){ R = Math.min(R, levees.right.station); }
  return {L, R};
}

/* ===================== MAIN COMPUTE ===================== */
function compute(){
  updateSliceOptionStates();
  const nLOB=parseFloat(document.getElementById('nLOB').value);
  const nMC =parseFloat(document.getElementById('nMC').value);
  const nROB=parseFloat(document.getElementById('nROB').value);
  const S   =parseFloat(document.getElementById('slope').value);
  const D   =parseFloat(document.getElementById('depth').value);
  const units=document.getElementById('units').value;
  const plotMode=(document.querySelector('input[name="plotMode"]:checked')||{}).value || 'off';
  const hvnOn = document.getElementById('hvnToggle').checked;
  const useQ = !!document.getElementById('specifyQ').checked;
  const Qtarget = parseFloat(document.getElementById('discharge').value);

  const plotShade=document.getElementById('plotShade');
  const plotNote =document.getElementById('plotNote');
  const resShade =document.getElementById('resultsShade');
  const resNote =document.getElementById('resultsNote');
  const distShade=document.getElementById('distShade');
  const distNote =document.getElementById('distNote');
  const convShade=document.getElementById('convShade');
  const convNote =document.getElementById('convNote');
  [plotShade,plotNote,resShade,resNote,distShade,distNote,convShade,convNote].forEach(el=>{ el.style.display='none'; el.textContent=''; });
  document.getElementById('summary').classList.remove('disabled');
  document.getElementById('distTable').classList.remove('disabled');
  document.getElementById('convTable').classList.remove('disabled');

  function greyOutAll(msg){
    [plotShade, plotNote, resShade, resNote, distShade, distNote, convShade, convNote].forEach(el=>el.style.display='flex');
    plotNote.textContent=msg; resNote.textContent=msg; distNote.textContent=msg; convNote.textContent=msg;
    document.getElementById('summary').classList.add('disabled');
    document.getElementById('distTable').classList.add('disabled');
    document.getElementById('convTable').classList.add('disabled');
  }
  function greyOutDist(msg){
    [distShade, distNote].forEach(el=>el.style.display='flex');
    distNote.textContent=msg;
    document.getElementById('distTable').classList.add('disabled');
  }

  if(!(S>0) || (!useQ && !(D>=0)) || (useQ && !(Qtarget>=0))){
    greyOutAll('Enter positive slope S and ' + (useQ ? 'non‑negative discharge Q.' : 'non‑negative depth D.'));
    renderPlot([], NaN, [], units, { mode:'off' });
    renderDistTable(null, units, 0, 0);
    renderConveyanceTable(null, units, null);
    renumberIDs(); return;
  }

  const raw=getPointsWithStagesRaw();
  if(raw.length<2){
    greyOutAll('Not enough data: provide at least two Station–Elevation points, and select LB & RB.');
    renderPlot([], NaN, [], units, { mode:'off' });
    renderDistTable(null, units, 0, 0);
    renderConveyanceTable(null, units, null);
    renumberIDs(); return;
  }

  const stations=raw.map(p=>p.x);
  const hasDup=(new Set(stations)).size!==stations.length;
  const isStrictIncreasing=stations.every((v,i,a)=> i===0 || v>a[i-1]);
  const minZ=Math.min(...raw.map(p=>p.z));
  let stage=minZ + (Number.isFinite(D)?D:0);

  if(hasDup){
    greyOutAll('Station values must be unique.');
    renderPlot(raw, stage, [], units, { mode:'off' });
    renderDistTable(null, units, 0, 0);
    renderConveyanceTable(null, units, null);
    renumberIDs(); return;
  }
  if(!isStrictIncreasing){
    greyOutAll('Stations must increase left→right. Use the “Sort by Station” button.');
    renderPlot(raw, stage, [], units, { mode:'off' });
    renderDistTable(null, units, 0, 0);
    renderConveyanceTable(null, units, null);
    renumberIDs(); return;
  }

  const pts=raw;
  const LB=pts.find(p=>p.tag==='LB')||null;
  const RB=pts.find(p=>p.tag==='RB')||null;
  if(!LB || !RB || !(LB.x<RB.x)){
    greyOutAll('Not enough information: select exactly one LB and one RB (LB must be left of RB).');
    renderPlot(pts, stage, [], units, { mode:'off' });
    renderDistTable(null, units, 0, 0);
    renderConveyanceTable(null, units, null);
    renumberIDs(); return;
  }

  // If HVn is ON, validate segments before solving for discharge
  if(hvnOn){
    const rowsSortedCheck = getPointsWithStagesRaw();
    const builtCheck = buildNSegments(rowsSortedCheck);
    if(!builtCheck.ok){
      greyOutAll(builtCheck.err);
      renderPlot(pts, stage, [], units, { mode:'off' });
      renderDistTable(null, units, 0, 0);
      renderConveyanceTable(null, units, null);
      return;
    }
  }

  // Specify Discharge mode: find stage that meets target Q
  if(useQ){
    const xMinTmp=pts[0].x, xMaxTmp=pts[pts.length-1].x;
    const kConstTmp=(units==='US')?1.486:1.0;
    const sqrtSTmp=Math.sqrt(S);
    let hvnSegs=null, SL=null, SR=null, uniqueNs=null;
    if(hvnOn){
      const rowsSorted = getPointsWithStagesRaw();
      const built = buildNSegments(rowsSorted);
      hvnSegs = built.segments || [];
      const br = bankSlopeRatios(pts, LB.x, RB.x); SL=br.SL; SR=br.SR;
      uniqueNs = Array.from(new Set(hvnSegs.map(s=>s.n).filter(Number.isFinite)));
    }
    function Q_of_stage(stageVal){
      const convBedTmp = buildConveyanceBed(pts, stageVal);
      const clipTmp = leveeClip(stageVal, xMinTmp, xMaxTmp);
      const leftGeomTmp =integrateSectionInRangeOnBed(convBedTmp, stageVal, clipTmp.L, Math.min(LB.x, clipTmp.R));
      const mainGeomTmp =integrateSectionInRangeOnBed(convBedTmp, stageVal, Math.max(LB.x, clipTmp.L), Math.min(RB.x, clipTmp.R));
      const rightGeomTmp=integrateSectionInRangeOnBed(convBedTmp, stageVal, Math.max(RB.x, clipTmp.L), clipTmp.R);
      function partK(geom,n){ const A=geom.A,P=geom.P; const R=(A>0&&P>0)?A/P:0; const AR23=(A>0&&R>0)?A*Math.pow(R,2/3):0; return (AR23>0&&n>0)?(kConstTmp/n)*AR23:0; }
      if(!hvnOn){
        const Ksum = partK(leftGeomTmp,nLOB)+partK(mainGeomTmp,nMC)+partK(rightGeomTmp,nROB);
        return Ksum*sqrtSTmp;
      }else{
        const leftSegs = clipSegments(hvnSegs, clipTmp.L, Math.min(LB.x, clipTmp.R));
        const chSegs   = clipSegments(hvnSegs, Math.max(LB.x, clipTmp.L), Math.min(RB.x, clipTmp.R));
        const rightSegs= clipSegments(hvnSegs, Math.max(RB.x, clipTmp.L), clipTmp.R);
        function KsumFromSegs(segList){ let s=0; for(const seg of segList){ const g=integrateSectionInRangeOnBed(convBedTmp, stageVal, seg.xL, seg.xR); const A=g.A,P=g.P; const R=(A>0&&P>0)?A/P:0; const AR23=(A>0&&R>0)?A*Math.pow(R,2/3):0; const K=(AR23>0&&seg.n>0)?(kConstTmp/seg.n)*AR23:0; s+=K; } return s; }
        const useComposite = (uniqueNs? uniqueNs.length>=2:false) && ((SL??Infinity)<5.0 || (SR??Infinity)<5.0);
        let K_C=0;
        if(useComposite){ let P_C=0, top=0; const A_C=mainGeomTmp.A; for(const seg of chSegs){ const g=integrateSectionInRangeOnBed(convBedTmp, stageVal, seg.xL, seg.xR); P_C+=g.P; top+=g.P*Math.pow(seg.n,1.5);} const n_c=(P_C>0)?Math.pow(top/P_C,2/3):(uniqueNs&&uniqueNs.length?uniqueNs[0]:NaN); const R_C=(P_C>0&&A_C>0)?A_C/P_C:0; const AR23_C=(A_C>0&&R_C>0)?A_C*Math.pow(R_C,2/3):0; K_C=(n_c>0&&AR23_C>0)?(kConstTmp/n_c)*AR23_C:0; }
        else { K_C = KsumFromSegs(chSegs); }
        const Ksum = KsumFromSegs(leftSegs) + K_C + KsumFromSegs(rightSegs);
        return Ksum*sqrtSTmp;
      }
    }
    if(Qtarget<=0 || !Number.isFinite(Qtarget)){
      stage = minZ;
      // Reflect depth even when Q is zero/invalid (at most 2 decimals)
      {
        const dShown = Math.max(0, stage - minZ);
        document.getElementById('depth').value = +dShown.toFixed(2);
      }
    }else{
      let dLo=0, dHi=(Number.isFinite(D)&&D>0)?D:1.0; let qHi=Q_of_stage(minZ+dHi); let n=0;
      while(qHi<Qtarget && dHi<1e6 && n<60){ dHi*=2; qHi=Q_of_stage(minZ+dHi); n++; }
      if(!(qHi>=Qtarget)){
        stage=minZ+dHi;
      }else{
        for(let k=0;k<60;k++){
          const dMid=0.5*(dLo+dHi); const qMid=Q_of_stage(minZ+dMid);
          if(!Number.isFinite(qMid)) break;
          if(Math.abs(qMid-Qtarget) <= Math.max(1e-6, 1e-6*Qtarget)){ dLo=dHi=dMid; break; }
          if(qMid<Qtarget) dLo=dMid; else dHi=dMid;
          if((dHi-dLo)<=1e-6) break;
        }
        stage=minZ+0.5*(dLo+dHi);
      }
      {
        const dShown = Math.max(0, stage - minZ);
        document.getElementById('depth').value = +dShown.toFixed(2); // at most 2 decimals
      }
    }
  }

  const xMin=pts[0].x, xMax=pts[pts.length-1].x;
  const convBed = buildConveyanceBed(pts, stage);
  const clip = leveeClip(stage, xMin, xMax);

  const whole=integrateSectionInRangeOnBed(convBed, stage, clip.L, clip.R);
  const leftGeom =integrateSectionInRangeOnBed(convBed, stage, clip.L, Math.min(LB.x, clip.R));
  const mainGeom =integrateSectionInRangeOnBed(convBed, stage, Math.max(LB.x, clip.L), Math.min(RB.x, clip.R));
  const rightGeom=integrateSectionInRangeOnBed(convBed, stage, Math.max(RB.x, clip.L), clip.R);

  const kConst=(units==='US')?1.486:1.0;
  const g =(units==='US')?32.174:9.80665;
  const sqrtS =Math.sqrt(S);
  const gamma =(units==='US')?62.4:9810;

  let metrics, Qtot, Korig, convReport;

  const eqN_fromPanels = (panels)=>{
    let sumAR=0, denom=0;
    for(const p of panels){
      const R=(p.A>0 && p.P>0)? p.A/p.P : 0;
      const AR23=(p.A>0 && R>0)? p.A*Math.pow(R,2/3) : 0;
      sumAR += AR23;
      denom += (p.n>0 ? AR23/p.n : 0);
    }
    return (sumAR>0 && denom>0)? (sumAR/denom) : NaN;
  };

  if(!hvnOn){
    function partMetrics(geom, nPart){
      const A=geom.A, P=geom.P, T=geom.T;
      const R=(P>0&&A>0)?A/P:0;
      const AR23=(A>0&&R>0)? A*Math.pow(R,2/3):0;
      const K=(AR23>0)?(kConst/nPart)*AR23:0;
      const Q=K*sqrtS;
      const V=(A>0)?Q/A:0;
      const Davg=(T>0)?A/T:0;
      const tau=gamma*R*S;
      const streamPower=tau*V;
      const Fr=(Davg>0)? V/Math.sqrt(g*Davg):0;
      return {A,P,T,R,K,Q,V,Davg,tau,streamPower,Fr,AR23};
    }
    const mLeft =partMetrics(leftGeom, nLOB);
    const mMain =partMetrics(mainGeom, nMC);
    const mRight=partMetrics(rightGeom, nROB);

    const Ktot=mLeft.K + mMain.K + mRight.K;
    Qtot=Ktot*sqrtS;
    const nXS = eqN_fromPanels([
      {A:leftGeom.A, P:leftGeom.P, n:nLOB},
      {A:mainGeom.A, P:mainGeom.P, n:nMC },
      {A:rightGeom.A, P:rightGeom.P, n:nROB}
    ]);
    const Atot=leftGeom.A + mainGeom.A + rightGeom.A;
    const Ptot=leftGeom.P + mainGeom.P + rightGeom.P;
    const Ttot=whole.T;
    const Rtot=(Atot>0&&Ptot>0)? Atot/Ptot:0;
    const Vtot=(Atot>0)? Qtot/Atot:0;
    const DavgTot=(Ttot>0)? Atot/Ttot:0;
    const tauTot=gamma*Rtot*S;
    const streamPowerTot=tauTot*Vtot;
    const FrTot=(DavgTot>0)? Vtot/Math.sqrt(g*DavgTot):0;

    metrics = {
      XS:{Q:Qtot, n:nXS, V:Vtot, P:Ptot, A:Atot, R:Rtot, T:Ttot, D:DavgTot, Dmax:Math.max(stage-Math.min(...pts.map(p=>p.z)),0), tau:tauTot, sp:streamPowerTot, Fr:FrTot},
      MC:{Q:mMain.Q, n:nMC, V:mMain.V, P:mainGeom.P, A:mainGeom.A, R:mMain.R, T:mainGeom.T, D:mMain.Davg, Dmax:Math.max(0, stage - Math.min(mainGeom.wetIntervals.length?Math.min(...polylineBetween(pts,LB.x,RB.x).map(p=>p.z)):stage, stage)), tau:mMain.tau, sp:mMain.streamPower, Fr:mMain.Fr},
      LO:{Q:mLeft.Q, n:nLOB, V:mLeft.V, P:leftGeom.P, A:leftGeom.A, R:mLeft.R, T:leftGeom.T, D:mLeft.Davg, Dmax:Math.max(0, stage - Math.min(leftGeom.wetIntervals.length?Math.min(...polylineBetween(pts,xMin,LB.x).map(p=>p.z)):stage, stage)), tau:mLeft.tau, sp:mLeft.streamPower, Fr:mLeft.Fr},
      RO:{Q:mRight.Q, n:nROB, V:mRight.V, P:rightGeom.P, A:rightGeom.A, R:mRight.R, T:rightGeom.T, D:mRight.Davg, Dmax:Math.max(0, stage - Math.min(rightGeom.wetIntervals.length?Math.min(...polylineBetween(pts,RB.x,xMax).map(p=>p.z)):stage, stage)), tau:mRight.tau, sp:mRight.streamPower, Fr:mRight.Fr}
    };
    Korig = (sqrtS>0)? (Qtot/sqrtS) : 0;
    convReport = null;
  }else{
    const rowsSorted=getPointsWithStagesRaw();
    const built=buildNSegments(rowsSorted);
    if(!built.ok){
      greyOutAll(built.err);
      renderPlot(pts, stage, [], units, { mode:'off' });
      renderDistTable(null, units, 0, 0);
      renderConveyanceTable(null, units, null);
      return;
    }
    const segs=built.segments;
    const leftSegs = clipSegments(segs, clip.L, Math.min(LB.x, clip.R));
    const rightSegs= clipSegments(segs, Math.max(RB.x, clip.L), clip.R);

    function computePartFromSegments(segList){
      const items=[];
      let sumK=0, sumA=0, sumP=0, sumAR23=0, denom=0;
      for(const s of segList){
        const geom=integrateSectionInRangeOnBed(convBed, stage, s.xL, s.xR);
        const A=geom.A, P=geom.P;
        const R=(A>0&&P>0)? A/P : 0;
        const AR23=(A>0&&R>0)? A*Math.pow(R,2/3):0;
        const K=(AR23>0 && s.n>0)? (kConst/s.n)*AR23 : 0;
        items.push({zone:'', xL:s.xL, xR:s.xR, n:s.n, A, P, R, K, AR23});
        sumK+=K; sumA+=A; sumP+=P; sumAR23+=AR23; denom += (s.n>0? AR23/s.n : 0);
      }
      const Rpart=(sumA>0&&sumP>0)? sumA/sumP : 0;
      return {items, Ksum:sumK, Asum:sumA, Psum:sumP, Rpart, sumAR23, denomAR:denom};
    }

    const chSegs = clipSegments(segs, Math.max(LB.x, clip.L), Math.min(RB.x, clip.R));
    const uniqueNs = Array.from(new Set(chSegs.map(s=>s.n).filter(Number.isFinite)));
    const {SL, SR} = bankSlopeRatios(pts, LB.x, RB.x);
    const useComposite = (uniqueNs.length>=2) && ((SL < 5.0) || (SR < 5.0));

    const leftPart = computePartFromSegments(leftSegs);
    const rightPart = computePartFromSegments(rightSegs);

    let chItems=[], K_C=0, A_C=mainGeom.A, P_C=0, R_C=0, n_c=null, AR23_C=0, denomCH=0;
    if(useComposite){
      const pPieces=[]; for(const s of chSegs){ const geom=integrateSectionInRangeOnBed(convBed, stage, s.xL, s.xR); pPieces.push({n:s.n, P:geom.P}); }
      P_C = pPieces.reduce((a,b)=>a+b.P,0);
      const top = pPieces.reduce((a,b)=>a + b.P*Math.pow(b.n,1.5), 0);
      n_c = (P_C>0)? Math.pow(top/P_C, 2/3) : uniqueNs[0] || NaN;
      R_C = (P_C>0 && A_C>0)? (A_C/P_C) : 0;
      AR23_C = (A_C>0 && R_C>0)? A_C*Math.pow(R_C,2/3) : 0;
      K_C = (n_c>0 && AR23_C>0)? (kConst/n_c)*AR23_C : 0;
      denomCH = (n_c>0)? AR23_C/n_c : 0;
      chItems.push({zone:'Channel (composite)', xL:Math.max(LB.x, clip.L), xR:Math.min(RB.x, clip.R), n:n_c, A:A_C, P:P_C, R:R_C, K:K_C, AR23:AR23_C});
    }else{
      const chPart = computePartFromSegments(chSegs);
      chItems = chPart.items.map(o=>({zone:'Channel', ...o}));
      K_C = chPart.Ksum; A_C=chPart.Asum; P_C=chPart.Psum; R_C=chPart.Rpart; AR23_C = chPart.sumAR23; denomCH = chPart.denomAR;
    }

    const K_L = leftPart.Ksum, K_R = rightPart.Ksum;
    const K_T = K_L + K_C + K_R;
    Qtot = K_T * sqrtS;
    Korig = (sqrtS>0)? (Qtot/sqrtS) : 0;

    const Atot=leftPart.Asum + A_C + rightPart.Asum;
    const Ptot=leftPart.Psum + P_C + rightPart.Psum;
    const Ttot=whole.T;
    const Rtot=(Atot>0&&Ptot>0)? Atot/Ptot:0;

    const sumAR_LO = leftPart.sumAR23, denomLO = leftPart.denomAR;
    const sumAR_RO = rightPart.sumAR23, denomRO = rightPart.denomAR;
    const sumAR_XS = sumAR_LO + AR23_C + sumAR_RO;
    const denomXS = denomLO + denomCH + denomRO;

    const n_LO = (sumAR_LO>0 && denomLO>0)? sumAR_LO/denomLO : NaN;
    const n_MC = useComposite ? n_c : (AR23_C>0 && denomCH>0 ? AR23_C/denomCH : NaN);
    const n_RO = (sumAR_RO>0 && denomRO>0)? sumAR_RO/denomRO : NaN;
    const n_XS = (sumAR_XS>0 && denomXS>0)? sumAR_XS/denomXS : NaN;

    const Vtot=(Atot>0)? Qtot/Atot:0;
    const DavgTot=(Ttot>0)? Atot/Ttot:0;
    const tauTot=gamma*Rtot*S;
    const streamPowerTot=tauTot*Vtot;
    const FrTot=(DavgTot>0)? Vtot/Math.sqrt(g*DavgTot):0;

    metrics = {
      XS:{Q:Qtot, n:n_XS, V:Vtot, P:Ptot, A:Atot, R:Rtot, T:Ttot, D:DavgTot, Dmax:Math.max(stage-Math.min(...pts.map(p=>p.z)),0), tau:tauTot, sp:streamPowerTot, Fr:FrTot},
      MC:{Q:(K_C*sqrtS), n:n_MC, V:(A_C>0?(K_C*sqrtS)/A_C:0), P:P_C, A:A_C, R:R_C, T:mainGeom.T, D:(Ttot>0?A_C/Ttot:0),
          Dmax:Math.max(0, stage - Math.min(mainGeom.wetIntervals.length?Math.min(...polylineBetween(pts,LB.x,RB.x).map(p=>p.z)):stage, stage)),
          tau:gamma*R_C*S, sp:(gamma*R_C*S)*(A_C>0?(K_C*sqrtS)/A_C:0), Fr:((Ttot>0?A_C/Ttot:0)>0? ((A_C>0?(K_C*sqrtS)/A_C:0) / Math.sqrt(g*(A_C/Ttot)) ):0)},
      LO:{Q:(K_L*sqrtS), n:n_LO, V:(leftPart.Asum>0?(K_L*sqrtS)/leftPart.Asum:0), P:leftPart.Psum, A:leftPart.Asum, R:leftPart.Rpart, T:leftGeom.T, D:(Ttot>0?leftPart.Asum/Ttot:0),
          Dmax:Math.max(0, stage - Math.min(leftGeom.wetIntervals.length?Math.min(...polylineBetween(pts,xMin,LB.x).map(p=>p.z)):stage, stage)),
          tau:gamma*leftPart.Rpart*S, sp:(gamma*leftPart.Rpart*S)*(leftPart.Asum>0?(K_L*sqrtS)/leftPart.Asum:0), Fr:((Ttot>0?leftPart.Asum/Ttot:0)>0? ((leftPart.Asum>0?(K_L*sqrtS)/leftPart.Asum:0) / Math.sqrt(g*(leftPart.Asum/Ttot)) ):0)},
      RO:{Q:(K_R*sqrtS), n:n_RO, V:(rightPart.Asum>0?(K_R*sqrtS)/rightPart.Asum:0), P:rightPart.Psum, A:rightPart.Asum, R:rightPart.Rpart, T:rightGeom.T, D:(Ttot>0?rightPart.Asum/Ttot:0),
          Dmax:Math.max(0, stage - Math.min(rightGeom.wetIntervals.length?Math.min(...polylineBetween(pts,RB.x,xMax).map(p=>p.z)):stage, stage)),
          tau:gamma*rightPart.Rpart*S, sp:(gamma*rightPart.Rpart*S)*(rightPart.Asum>0?(K_R*sqrtS)/rightPart.Asum:0), Fr:((Ttot>0?rightPart.Asum/Ttot:0)>0? ((rightPart.Asum>0?(K_R*sqrtS)/rightPart.Asum:0) / Math.sqrt(g*(rightPart.Asum/Ttot)) ):0)}
    };
    convReport = {
      K_L, K_C, K_R, K_T, Q:Qtot,
      parts: {
        left: leftPart.items.map(o=>({zone:'Left OB', ...o})),
        channel: chItems,
        right: rightPart.items.map(o=>({zone:'Right OB', ...o}))
      }
    };
  }

  renderSummary(metrics, units);
  // When using depth mode, reflect computed total Q in the Discharge input (rounded to 0.1)
  try{
    if(!useQ && metrics && metrics.XS && Number.isFinite(metrics.XS.Q)){
      const qEl=document.getElementById('discharge');
      qEl.value = +metrics.XS.Q.toFixed(1); // at most 1 decimal
    }
  }catch(_){/* noop */}

  let dist=null;
  const Ntotal=(parseInt(document.getElementById('N_LOB').value,10)||1) + (parseInt(document.getElementById('N_CHAN').value,10)||1) + (parseInt(document.getElementById('N_ROB').value,10)||1);
  if(Ntotal>45){
    greyOutDist(`Total slices (${Ntotal}) exceed cap of 45. Reduce LOB/Channel/ROB counts to ≤ 45 for HEC‑RAS parity.`);
    renderDistTable(null, units, 0, 0);
  }else{
    dist=computeDistribution(
      convBed, stage,
      {left:leftGeom, main:mainGeom, right:rightGeom},
      { nLOB:(hvnOn?NaN:nLOB), nMC:(hvnOn?NaN:nMC), nROB:(hvnOn?NaN:nROB) },
      { S, kConst, gamma, sqrtS },
      { N_LOB: parseInt(document.getElementById('N_LOB').value,10)||1,
        N_CH: parseInt(document.getElementById('N_CHAN').value,10)||1,
        N_ROB: parseInt(document.getElementById('N_ROB').value,10)||1 },
      metrics.XS.Q
    );
    renderDistTable(dist, units, metrics.XS.Q, (sqrtS>0?metrics.XS.Q/sqrtS:0));
  }

  renderConveyanceTable(hvnOn?convReport:null, units, null);

  // n-segments for plot
  let nSegments = [];
  if (hvnOn) {
    const rowsSorted2 = getPointsWithStagesRaw();
    nSegments = buildPlotNSegmentsFromExplicit(rowsSorted2, pts[0].x, pts[pts.length-1].x);
  } else {
    nSegments = [
      {xL: pts[0].x, xR: LB.x, n: nLOB},
      {xL: LB.x, xR: RB.x, n: nMC },
      {xL: RB.x, xR: pts[pts.length-1].x, n: nROB}
    ];
  }

  const bedForPlot = pts;
  let wetIntervals = integrateSectionInRangeOnBed(pts, stage, clip.L, clip.R).wetIntervals;
  renderPlot(bedForPlot, stage, wetIntervals, units, {
    mode: plotMode,
    dist,
    xsAvg:{V:metrics.XS.V, tau:metrics.XS.tau},
    nSegments,
    hcs: { ineffectiveAreas, obstructions, levees, clip }
  });
}

function computeDistribution(convBed, stage, parts, nVals, phys, Nvals, Qtot){
  const {left, main, right}=parts;
  const {nLOB, nMC, nROB}=nVals;
  const {S, kConst, gamma, sqrtS}=phys;
  const {N_LOB, N_CH, N_ROB}=Nvals;

  const boundsLOB=partitionByWidth(left.wetIntervals, N_LOB);
  const boundsCH =partitionByWidth(main.wetIntervals, N_CH);
  const boundsROB=partitionByWidth(right.wetIntervals, N_ROB);

  const slices=[];
  function push(bounds,label,nVal){
    if(!bounds || bounds.length<2) return;
    for(let i=0;i<bounds.length-1;i++){
      const sL=bounds[i], sR=bounds[i+1];
      const geom=integrateSectionInRangeOnBed(convBed, stage, sL, sR);
      const A=geom.A, P=geom.P, Tw=geom.T;
      const R=(A>0&&P>0)?A/P:0; const Dh=(Tw>0)?A/Tw:0;
      const n_use = (Number.isFinite(nVal) && nVal>0)? nVal : 0.035;
      const AR23=(A>0&&R>0)? A*Math.pow(R,2/3):0;
      const Kraw=(AR23>0)?(kConst/n_use)*AR23:0;
      const Qraw=Kraw*sqrtS;
      slices.push({
        label: `${label} ${i+1}`, side:label, sL,sR,A,P,Tw,R,Dh,
        n:n_use, Kraw,Qraw, K:0,Q:0,V:0, tau:gamma*R*S, Power:0, mid:0, pctK:0
      });
    }
  }
  function partitionByWidth(intervals,N){
    const T=totalWetWidth(intervals);
    if(!(N>=1) || !(T>0)) return [];
    const step=T/N; const bounds=[];
    let acc=0,target=0,idx=0;
    if(intervals.length) bounds.push(intervals[0][0]);
    while(bounds.length<N){
      target+=step;
      while(idx<intervals.length && acc+(intervals[idx][1]-intervals[idx][0])<target-1e-12){
        acc+=(intervals[idx][1]-intervals[idx][0]); idx++;
      }
      if(idx>=intervals.length) break;
      const [a,b]=intervals[idx]; const within=target-acc; bounds.push(a+within);
    }
    if(intervals.length) bounds.push(intervals[intervals.length-1][1]);
    return bounds;
  }

  push(boundsLOB,'LOB', nLOB);
  push(boundsCH, 'Chan', nMC);
  push(boundsROB,'ROB', nROB);

  const SumKraw=slices.reduce((s,o)=>s+o.Kraw,0);
  const Korig=(sqrtS>0)? (Qtot/sqrtS) : 0;
  const r=(SumKraw>0)? (Korig/SumKraw) : 0;

  for(const sl of slices){
    sl.K=r*sl.Kraw; sl.Q=sl.K*sqrtS;
    sl.V=(sl.A>0)? sl.Q/sl.A : 0;
    sl.Power=sl.tau*sl.V;
    sl.mid=0.5*(sl.sL+sl.sR);
    sl.pctK=(Korig>0)? 100*sl.K/Korig : 0;
  }

  const boundaries=[]; const addB=a=>{ if(a&&a.length) for(const x of a) boundaries.push(x); };
  addB(boundsLOB); addB(boundsCH); addB(boundsROB);
  return {slices, boundaries, SumKraw, r, Korig};
}

/* Summary / Conveyance / Dist tables */
function renderSummary(data, units){
  const lenU=units==='US'?'ft':'m';
  const areaU=units==='US'?'ft²':'m²';
  const velU=units==='US'?'ft/s':'m/s';
  const qU =units==='US'?'cfs':'m³/s';
  const tauU=units==='US'?'lb/ft²':'Pa';
  const spU =units==='US'?'lb/(ft·s)':'N/(m·s)';

  const rows=[
    ['Discharge', m=>fmt(m.Q), qU],
    ['n (used)', m=>Number.isFinite(m.n)? m.n.toFixed(3) : '—', ''],
    ['Velocity Avg', m=>fmt(m.V), velU],
    ['Wetted Perimeter', m=>fmt(m.P), lenU],
    ['Area', m=>fmt(m.A), areaU],
    ['Hydraulic Radius R', m=>fmt(m.R), lenU],
    ['Top Width', m=>fmt(m.T), lenU],
    ['Depth avg', m=>fmt(m.D), lenU],
    ['Depth max', m=>fmt(m.Dmax), lenU],
    ['Shear Stress avg', m=>fmt(m.tau),tauU],
    ['Unit Stream Power', m=>fmt(m.sp), spU],
    ['Froude', m=>fmt(m.Fr), '']
  ];

  const cols=[ ['XS Average','XS'], ['Main Channel','MC'], ['Left Overbank','LO'], ['Right Overbank','RO'] ];

  let html='<thead><tr><th>Metric</th>';
  for(const [label] of cols) html+=`<th>${label}</th>`;
  html+='</tr></thead><tbody>';
  for(const [label,get,unit] of rows){
    const withUnit = unit ? `${label} (${unit})` : label;
    html+=`<tr><th>${withUnit}</th>`;
    for (const [,key] of cols) html+=`<td>${get(data[key])}</td>`;
    html+='</tr>';
  }
  html+='</tbody>';
  document.getElementById('summary').innerHTML=html;
}

function renderConveyanceTable(report, units, phys){
  const tbl=document.getElementById('convTable');
  const shade=document.getElementById('convShade');
  const note=document.getElementById('convNote');
  shade.style.display='none'; note.style.display='none';
  if(!report){
    tbl.innerHTML = `
      <thead><tr>
        <th>Zone</th><th>Left Sta</th><th>Right Sta</th><th>n</th><th>A</th><th>P</th><th>R</th><th>K</th>
      </tr></thead>
      <tbody><tr><td colspan="8">Horizontal variation of n is OFF.</td></tr></tbody>
    `;
    return;
  }
  const lenU=units==='US'?'ft':'m';
  const areaU=units==='US'?'ft²':'m²';
  const kUnit = units==='US' ? 'cfs/√S' : 'm³/s/√S';

  function row(o){
    return `<tr>
      <td>${o.zone||''}</td>
      <td>${fmt(o.xL)}</td>
      <td>${fmt(o.xR)}</td>
      <td>${Number.isFinite(o.n)? o.n.toFixed(3) : '—'}</td>
      <td>${fmt(o.A)}</td>
      <td>${fmt(o.P)}</td>
      <td>${fmt(o.R)}</td>
      <td>${fmt(o.K)}</td>
    </tr>`;
  }

  let html = `<thead><tr>
    <th>Zone</th>
    <th>Left Sta (${lenU})</th>
    <th>Right Sta (${lenU})</th>
    <th>n</th>
    <th>A (${areaU})</th>
    <th>P (${lenU})</th>
    <th>R (${lenU})</th>
    <th>K (${kUnit})</th>
  </tr></thead><tbody>`;

  for(const o of report.parts.left) html+=row(o);
  for(const o of report.parts.channel)html+=row(o);
  for(const o of report.parts.right) html+=row(o);

  html+=`</tbody><tfoot><tr>
    <td colspan="8"><strong>K<sub>L</sub>=${fmt(report.K_L)}, K<sub>C</sub>=${fmt(report.K_C)}, K<sub>R</sub>=${fmt(report.K_R)}, K<sub>total</sub>=${fmt(report.K_T)}, Q=${fmt(report.Q)}</strong></td>
  </tr></tfoot>`;
  tbl.innerHTML = html;
}

function renderDistTable(dist, units, Qtot, Korig){
  const tbl=document.getElementById('distTable');
  const lenU=units==='US'?'ft':'m';
  const areaU=units==='US'?'ft²':'m²';
  const velU=units==='US'?'ft/s':'m/s';
  const qU =units==='US'?'cfs':'m³/s';
  const tauU=units==='US'?'lb/ft²':'Pa';
  const powU=units==='US'?'lb/(ft·s)':'N/(m·s)';

  let html= `<thead><tr>
    <th>Pos</th>
    <th>Left Sta (${lenU})</th>
    <th>Right Sta (${lenU})</th>
    <th>Flow (${qU})</th>
    <th>Area (${areaU})</th>
    <th>W.P. (${lenU})</th>
    <th>Percent Conv (%)</th>
    <th>Hydr Depth (${lenU})</th>
    <th>Velocity (${velU})</th>
    <th>Shear (${tauU})</th>
    <th>Power (${powU})</th>
  </tr></thead><tbody>`;

  let sumQ=0, sumPct=0;
  if(dist && dist.slices && dist.slices.length){
    for(const s of dist.slices){
      html+= `<tr>
        <td>${s.label}</td>
        <td>${fmt(s.sL)}</td>
        <td>${fmt(s.sR)}</td>
        <td>${fmt(s.Q)}</td>
        <td>${fmt(s.A)}</td>
        <td>${fmt(s.P)}</td>
        <td>${fmt(s.pctK)}</td>
        <td>${fmt(s.Dh)}</td>
        <td>${fmt(s.V)}</td>
        <td>${fmt(s.tau)}</td>
        <td>${fmt(s.Power)}</td>
      </tr>`;
      sumQ+=s.Q; sumPct+=s.pctK;
    }
  }
  html+=`</tbody><tfoot><tr>
    <td>Totals</td><td></td><td></td>
    <td>${fmt(sumQ)}</td><td></td><td></td>
    <td>${fmt(sumPct)}</td><td></td><td></td><td></td><td></td>
  </tr></tfoot>`;
  tbl.innerHTML=html;
}

/* ===================== PLOT ===================== */
function renderPlot(pts, stage, wetIntervals = [], units, opts){
  const svg=document.getElementById('plot');
  svg.innerHTML='';
  const W=svg.viewBox.baseVal.width||1000, H=svg.viewBox.baseVal.height||360;
  if(!pts || pts.length<2) return;

  const defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.appendChild(defs);

  const M={left:116,right:170,top:46,bottom:72};
  const innerW=Math.max(10, W - M.left - M.right);
  const innerH=Math.max(10, H - M.top - M.bottom);

  const xs=pts.map(p=>p.x), zs=pts.map(p=>p.z);
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const padX=(maxX-minX)*0.08 || 1;
  const x0=minX-padX, x1=maxX+padX;

  const maxBed=Math.max(...zs), minBed=Math.min(...zs);
  const maxTarget = Number.isFinite(stage) ? Math.max(maxBed, stage) : maxBed;

  const probe=niceTicks(minBed, maxTarget, 6);
  let yStep=(probe.length>=2)?(probe[1]-probe[0]):((maxTarget-minBed)||1);
  if(!(yStep>0)) yStep=0.5;
  const z0=Math.floor(minBed/yStep)*yStep;
  const z1=(Math.floor(maxTarget+yStep*0.01)/yStep+1)*yStep;
  const yTicksOverride=ticksFromStep(z0, z1, yStep);

  const sx=x=> M.left + ((x - x0)/(x1 - x0))*innerW;
  const sy=z=> M.top + (1 - (z - z0)/(z1 - z0))*innerH;

  drawAxes(svg,x0,x1,z0,z1,sx,sy,units,M,W,H,yTicksOverride);

  // n labels strip near the top
  const yN = sy(z1) - 15;
  const cap = 8;

  function drawSpan(a,b,val){
    if(!(b>a)) return;
    const xL=sx(a), xR=sx(b), xMid=(xL+xR)/2;

    // main horizontal n line
    const hLine=document.createElementNS('http://www.w3.org/2000/svg','line');
    hLine.setAttribute('x1',xL); hLine.setAttribute('y1',yN);
    hLine.setAttribute('x2',xR); hLine.setAttribute('y2',yN);
    hLine.setAttribute('stroke','#444');
    hLine.setAttribute('stroke-width','2');                 
    svg.appendChild(hLine);

    // end caps (thick)
    const c1=document.createElementNS('http://www.w3.org/2000/svg','line');
	c1.setAttribute('x1',xL); c1.setAttribute('y1',yN - cap/2);
	c1.setAttribute('x2',xL); c1.setAttribute('y2',yN + cap/2);
    c1.setAttribute('stroke','#444');
    c1.setAttribute('stroke-width','2');                    
    svg.appendChild(c1);

    const c2=document.createElementNS('http://www.w3.org/2000/svg','line');
	c2.setAttribute('x1',xR); c2.setAttribute('y1',yN - cap/2);
	c2.setAttribute('x2',xR); c2.setAttribute('y2',yN + cap/2);
    c2.setAttribute('stroke','#444');
    c2.setAttribute('stroke-width','2');                    
    svg.appendChild(c2);

    // label
	const label = (+val).toFixed(6).replace(/\.?0+$/, '').replace(/^0\./,'.');
    const txt=document.createElementNS('http://www.w3.org/2000/svg','text');
    txt.setAttribute('x',xMid); txt.setAttribute('y',yN);
    txt.setAttribute('text-anchor','middle'); txt.setAttribute('dominant-baseline','middle');
    txt.setAttribute('class','nlabel'); txt.textContent=label;
    svg.appendChild(txt);

    // white background for label
    const bb=txt.getBBox(); const pad=3.5;
    const bg=document.createElementNS('http://www.w3.org/2000/svg','rect');
    bg.setAttribute('x', bb.x - pad); bg.setAttribute('y', bb.y - pad);
    bg.setAttribute('width', bb.width + 2*pad); bg.setAttribute('height', bb.height + 2*pad);
    bg.setAttribute('fill','#fff'); bg.setAttribute('rx','4'); bg.setAttribute('ry','4');
    svg.insertBefore(bg, txt);
  }

  if (opts && Array.isArray(opts.nSegments) && opts.nSegments.length){
    for (const seg of opts.nSegments) {
      if (Number.isFinite(seg.n)) drawSpan(seg.xL, seg.xR, seg.n);
    }
  }

  // Water fill
  if (Number.isFinite(stage) && wetIntervals && wetIntervals.length){
    for(const [a,b] of wetIntervals){
      const seg=polylineBetween(pts, a, b);
      if(seg.length>=2){
        const d=['M', sx(a), sy(stage), 'L'];
        seg.forEach((p,i)=>{ d.push(i?',':'', sx(p.x), sy(p.z)); });
        d.push('L', sx(b), sy(stage), 'Z');
        const path=document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', d.join(' '));
        path.setAttribute('fill','#4da3ff'); path.setAttribute('opacity','0.28'); path.setAttribute('stroke','none');
        svg.appendChild(path);
      }
    }
  }

  // Obstructions fill
  if (opts?.hcs?.obstructions?.length){
    for(const ob of opts.hcs.obstructions){
      if(!ob || !Number.isFinite(ob.l) || !Number.isFinite(ob.r) || !Number.isFinite(ob.top)) continue;
      const xl=Math.min(ob.l,ob.r), xr=Math.max(ob.l,ob.r);
      const seg=polylineBetween(pts, xl, xr);
      if(seg.length>=2){
        const d=['M', sx(xl), sy(ob.top)];
        seg.forEach((p,i)=>{ d.push(i?',':'','L', sx(p.x), sy(Math.min(p.z, ob.top))); });
        d.push('L', sx(xr), sy(ob.top), 'Z');
        const path=document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', d.join(' '));
        path.setAttribute('fill', '#555'); path.setAttribute('opacity','0.9'); path.setAttribute('stroke','none');
        svg.appendChild(path);
      }
    }
  }

  // IFA hatching
  if (opts?.hcs?.ineffectiveAreas?.length){
    let ifaIndex = 0;
    for(const ia of opts.hcs.ineffectiveAreas){
      if(!ia || !Number.isFinite(ia.l) || !Number.isFinite(ia.r) || !Number.isFinite(ia.elev)) continue;
      const xl=Math.min(ia.l, ia.r), xr=Math.max(ia.l, ia.r);
      const topZ = Math.min(stage, ia.elev);
      const seg=polylineBetween(pts, xl, xr);
      if(seg.length>=2){
        const d=['M', sx(xl), sy(topZ)];
        seg.forEach((p,i)=>{ const z = Math.min(p.z, topZ); d.push(i?',':'','L', sx(p.x), sy(z)); });
        d.push('L', sx(xr), sy(topZ), 'Z');
        const polyPath = d.join(' ');

        const clipId = `ifaClip_${ifaIndex++}`;
        const cp=document.createElementNS('http://www.w3.org/2000/svg','clipPath');
        cp.setAttribute('id', clipId); cp.setAttribute('clipPathUnits','userSpaceOnUse');
        const cpPath=document.createElementNS('http://www.w3.org/2000/svg','path'); cpPath.setAttribute('d', polyPath);
        cp.appendChild(cpPath); defs.appendChild(cp);

        const stripesG=document.createElementNS('http://www.w3.org/2000/svg','g');
        stripesG.setAttribute('clip-path', `url(#${clipId})`);
        const cx = M.left + innerW/2; const cy = M.top + innerH/2;
        const rotG=document.createElementNS('http://www.w3.org/2000/svg','g');
        rotG.setAttribute('transform', `rotate(-45 ${cx} ${cy})`);
        const green = getComputedStyle(document.documentElement).getPropertyValue('--green').trim() || '#2e7d32';
        const spacing = 10; const margin = W + H;
        const xStart = M.left - margin; const xEnd = M.left + innerW + margin;
        const yMin = M.top - margin; const yMax = M.top + innerH + margin;
        for(let y = yMin; y <= yMax; y += spacing){
          const ln=document.createElementNS('http://www.w3.org/2000/svg','line');
          ln.setAttribute('x1', xStart); ln.setAttribute('y1', y);
          ln.setAttribute('x2', xEnd); ln.setAttribute('y2', y);
          ln.setAttribute('stroke', green);
          ln.setAttribute('stroke-width', '2');
          ln.setAttribute('stroke-linecap', 'square');
          rotG.appendChild(ln);
        }
        stripesG.appendChild(rotG);
        svg.appendChild(stripesG);
      }
    }
  }

  // Bed line + points
  const bedPath=pts.map((p,i)=>(i?'L':'M')+sx(p.x)+','+sy(p.z)).join(' ');
  const bed=document.createElementNS('http://www.w3.org/2000/svg','path');
  bed.setAttribute('d',bedPath); bed.setAttribute('fill','none');
  bed.setAttribute('stroke','#222'); bed.setAttribute('stroke-width','2');
  svg.appendChild(bed);
  for(const p of pts){
    const c=document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx',sx(p.x)); c.setAttribute('cy',sy(p.z));
    c.setAttribute('r',(p.tag==='LB'||p.tag==='RB')?6.5:5.8);
    c.setAttribute('class',(p.tag==='LB'||p.tag==='RB')?'point bank':'point');
    svg.appendChild(c);
  }
  if(Number.isFinite(stage)){
    const line=document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',M.left); line.setAttribute('y1',sy(stage));
    line.setAttribute('x2',M.left+innerW); line.setAttribute('y2',sy(stage));
    line.setAttribute('stroke','#1e88e5'); line.setAttribute('stroke-dasharray','6 6');
    svg.appendChild(line);
  }

  // Levees + IFA guides
  if (opts?.hcs?.levees) {
    const magenta = getComputedStyle(document.documentElement).getPropertyValue('--magenta').trim() || '#c2185b';
    const zAtX = (x) => {
      for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i], b = pts[i + 1];
        if (x >= a.x && x <= b.x && b.x !== a.x) {
          const t = (x - a.x) / (b.x - a.x);
          return a.z + t * (b.z - a.z);
        }
      }
      return null;
    };
    const drawOne = (lev) => {
      if (!lev || !lev.enabled) return;
      if (!Number.isFinite(lev.station) || !Number.isFinite(lev.crest)) return;
      const xMin = pts[0].x, xMax = pts[pts.length - 1].x;
      if (lev.station < xMin || lev.station > xMax) return;
      const zBed = zAtX(lev.station); if (!Number.isFinite(zBed)) return;
      if (lev.crest <= zBed) return;
      const x = sx(lev.station); const yBed = sy(zBed); const yCrest = sy(lev.crest);
      const v = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      v.setAttribute('x1', x); v.setAttribute('y1', yBed);
      v.setAttribute('x2', x); v.setAttribute('y2', yCrest);
      v.setAttribute('stroke', magenta); v.setAttribute('stroke-width', '3');
      v.setAttribute('vector-effect', 'non-scaling-stroke'); svg.appendChild(v);
      const sz = 12; const cap = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      cap.setAttribute('x', x - sz / 2); cap.setAttribute('y', yCrest - sz / 2);
      cap.setAttribute('width', sz); cap.setAttribute('height', sz);
      cap.setAttribute('fill', 'none'); cap.setAttribute('stroke', magenta); cap.setAttribute('stroke-width', '2.5');
      cap.setAttribute('vector-effect', 'non-scaling-stroke'); svg.appendChild(cap);
    };
    drawOne(opts.hcs.levees.left); drawOne(opts.hcs.levees.right);
  }

  if (opts?.hcs?.ineffectiveAreas?.length){
    const green = getComputedStyle(document.documentElement).getPropertyValue('--green').trim() || '#2e7d32';
    for(const ia of opts.hcs.ineffectiveAreas){
      if(!ia || !Number.isFinite(ia.l) || !Number.isFinite(ia.r) || !Number.isFinite(ia.elev)) continue;
      const xl=Math.min(ia.l, ia.r), xr=Math.max(ia.l, ia.r);
      const seg=polylineBetween(pts, xl, xr);
      if(seg.length>=2){
        const zL = seg.length? seg[0].z : null;
        const zR = seg.length? seg[seg.length-1].z : null;
        const v1=document.createElementNS('http://www.w3.org/2000/svg','line');
        v1.setAttribute('x1', sx(xl)); v1.setAttribute('x2', sx(xl));
        v1.setAttribute('y1', sy(Math.min(zL, ia.elev))); v1.setAttribute('y2', sy(ia.elev));
        v1.setAttribute('stroke', green); v1.setAttribute('stroke-width','2'); svg.appendChild(v1);

        const v2=document.createElementNS('http://www.w3.org/2000/svg','line');
        v2.setAttribute('x1', sx(xr)); v2.setAttribute('x2', sx(xr));
        v2.setAttribute('y1', sy(Math.min(zR, ia.elev))); v2.setAttribute('y2', sy(ia.elev));
        v2.setAttribute('stroke', green); v2.setAttribute('stroke-width','2'); svg.appendChild(v2);

        function tri(xc,yc){
          const p=document.createElementNS('http://www.w3.org/2000/svg','path');
          const s=8;
          const d=`M ${xc} ${yc-5} l ${-s/2} ${s} h ${s} z`;
          p.setAttribute('d', d); p.setAttribute('fill', green); return p;
        }
        svg.appendChild(tri(sx(xl), sy(ia.elev)));
        svg.appendChild(tri(sx(xr), sy(ia.elev)));

        const h=document.createElementNS('http://www.w3.org/2000/svg','line');
        h.setAttribute('x1', sx(xl)); h.setAttribute('x2', sx(xr));
        h.setAttribute('y1', sy(ia.elev)); h.setAttribute('y2', sy(ia.elev));
        h.setAttribute('stroke', green); h.setAttribute('stroke-width','2');
        svg.appendChild(h);
      }
    }
  }

  const mode=(opts&&opts.mode)||'off';
  const xPlotRight=M.left+innerW;
  const TAU_AXIS_OFFSET = 84;

  if(mode==='slices' && opts?.dist?.slices?.length){
    const velMaxRaw=Math.max(...opts.dist.slices.map(s=>s.V),0);
    const tauMaxRaw=Math.max(...opts.dist.slices.map(s=>s.tau),0);
    const velTop=niceCeil(velMaxRaw);
    const tauUp =niceCeilPlusOneTick(tauMaxRaw);
    const tauTop=tauUp.top;
    const tauTicks=ticksFromStep(0, tauTop, tauUp.step);

    const yV=v=> M.top + (1 - (v/(velTop||1))) * innerH;
    const yT=t=> M.top + (1 - (t/(tauTop||1))) * innerH;

    const uniq=Array.from(new Set(opts.dist.boundaries.map(v=>+v.toFixed(12)))).sort((a,b)=>a-b);
    uniq.forEach(x=>{
      const l=document.createElementNS('http://www.w3.org/2000/svg','line');
      l.setAttribute('x1',sx(x)); l.setAttribute('y1',M.top);
      l.setAttribute('x2',sx(x)); l.setAttribute('y2',M.top+innerH);
      l.setAttribute('class','slice-boundary'); svg.appendChild(l);
    });

    const velPath=[], tauPath=[];
    for(const s of opts.dist.slices){
      const yyV=yV(s.V), yyT=yT(s.tau);
      const xL=sx(s.sL), xR=sx(s.sR);
      velPath.push(velPath.length?'L':'M', xL, yyV, 'L', xR, yyV);
      tauPath.push(tauPath.length?'L':'M', xL, yyT, 'L', xR, yyT);
    }
    const p1=document.createElementNS('http://www.w3.org/2000/svg','path');
    p1.setAttribute('d',velPath.join(' ')); p1.setAttribute('class','prof-vel'); svg.appendChild(p1);
    const p2=document.createElementNS('http://www.w3.org/2000/svg','path');
    p2.setAttribute('d',tauPath.join(' ')); p2.setAttribute('class','prof-tau'); svg.appendChild(p2);

    const xAxisVel=xPlotRight;
    const xAxisTau=xPlotRight + TAU_AXIS_OFFSET;
    drawSecondaryAxis(svg,xAxisVel,M.top,innerH,0,velTop, units==='US'?'ft/s':'m/s', true, '#b71c1c','Velocity', null);
    drawSecondaryAxis(svg,xAxisTau,M.top,innerH,0,tauTop, units==='US'?'lb/ft²':'Pa', true, '#6f42c1','Shear', tauTicks);
  } else if(mode==='xs' && opts?.xsAvg){
    const V=Math.max(0,+opts.xsAvg.V||0);
    const T=Math.max(0,+opts.xsAvg.tau||0);
    const velTop=niceCeil(V);
    const tauTop=niceCeil(T);
    const yV=v=> M.top + (1 - (v/(velTop||1))) * innerH;
    const yT=t=> M.top + (1 - (t/(tauTop||1))) * innerH;
    if(wetIntervals && wetIntervals.length){
      for(const [a,b] of wetIntervals){
        const vLine=document.createElementNS('http://www.w3.org/2000/svg','line');
        vLine.setAttribute('x1',sx(a)); vLine.setAttribute('x2',sx(b));
        vLine.setAttribute('y1',yV(V));  vLine.setAttribute('y2',yV(V));
        vLine.setAttribute('class','prof-vel'); svg.appendChild(vLine);

        const tLine=document.createElementNS('http://www.w3.org/2000/svg','line');
        tLine.setAttribute('x1',sx(a)); tLine.setAttribute('x2',sx(b));
        tLine.setAttribute('y1',yT(T));  tLine.setAttribute('y2',yT(T));
        tLine.setAttribute('class','prof-tau'); svg.appendChild(tLine);
      }
    }
    const xAxisVel=xPlotRight;
    const xAxisTau=xPlotRight + TAU_AXIS_OFFSET;
    drawSecondaryAxis(svg,xAxisVel,M.top,innerH,0,velTop, units==='US'?'ft/s':'m/s', true, '#b71c1c','Velocity', null);
    drawSecondaryAxis(svg,xAxisTau,M.top,innerH,0,tauTop, units==='US'?'lb/ft²':'Pa', true, '#6f42c1','Shear', null);
  }
}

function drawSecondaryAxis(svg,xAxis,yTop,h,vMin,vMax,unitLabel,labelsRight,color,title,tickList){
  const ax=document.createElementNS('http://www.w3.org/2000/svg','line');
  ax.setAttribute('x1',xAxis); ax.setAttribute('y1',yTop);
  ax.setAttribute('x2',xAxis); ax.setAttribute('y2',yTop+h);
  ax.setAttribute('class','secondary-axis');
  svg.appendChild(ax);

  const tickLen=7, labelPad=8, titlePad=56;
  const ticks=(tickList && tickList.length)? tickList : niceTicksSafe(vMin,vMax,5);
  const denom=(vMax-vMin);
  const mapY=v=> yTop + (1 - ((v - vMin)/(denom || 1)) )*h;

  ticks.forEach(v=>{
    const y=mapY(v);
    const t=document.createElementNS('http://www.w3.org/2000/svg','line');
    t.setAttribute('x1',xAxis); t.setAttribute('y1',y);
    t.setAttribute('x2',xAxis + (labelsRight? tickLen : -tickLen)); t.setAttribute('y2',y);
    t.setAttribute('class','secondary-tick'); t.setAttribute('style', `stroke:${color}`);
    svg.appendChild(t);

    const lbl=document.createElementNS('http://www.w3.org/2000/svg','text');
    const xLbl=xAxis + (labelsRight? (tickLen + labelPad) : (-tickLen - labelPad));
    lbl.setAttribute('x',xLbl); lbl.setAttribute('y',y+5);
    lbl.setAttribute('class','secondary-label');
    lbl.setAttribute('text-anchor', labelsRight ? 'start':'end');
    lbl.setAttribute('style', `fill:${color}`);
    lbl.textContent=fmtTick(v);
    svg.appendChild(lbl);
  });

  const titleEl=document.createElementNS('http://www.w3.org/2000/svg','text');
  const xLab=xAxis + (labelsRight? (tickLen + titlePad) : (-tickLen - titlePad));
  const yLab=yTop + h/2;
  titleEl.setAttribute('x',xLab); titleEl.setAttribute('y',yLab);
  titleEl.setAttribute('class','secondary-label'); titleEl.setAttribute('text-anchor','middle');
  titleEl.setAttribute('transform',`rotate(-90 ${xLab} ${yLab})`);
  titleEl.setAttribute('style', `fill:${color}`);
  titleEl.textContent=`${title} (${unitLabel})`;
  svg.appendChild(titleEl);
}

function drawAxes(svg,x0,x1,z0,z1,sx,sy,units,M,W,H,yTicksOverride=null){
  const xAxisY=M.top + (H - M.top - M.bottom);
  const yAxisX=M.left;
  const axis=(x1v,y1v,x2v,y2v,cls='axis')=>{
    const l=document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1',x1v); l.setAttribute('y1',y1v);
    l.setAttribute('x2',x2v); l.setAttribute('y2',y2v);
    l.setAttribute('class',cls); svg.appendChild(l);
  };
  axis(M.left, xAxisY, M.left + (W - M.left - M.right), xAxisY);
  axis(yAxisX, M.top, yAxisX, M.top + (H - M.top - M.bottom));

  const eps=1e-9, approxEq=(a,b)=> Math.abs(a-b) <= (Math.max(1,Math.abs(a),Math.abs(b))*1e-9);
  let xticks=niceTicksSafe(x0,x1,6).filter(v=>v>=x0-eps && v<=x1+eps);
  if(!xticks.length || !approxEq(xticks[0],x0)) xticks.unshift(x0);
  let yticks=(Array.isArray(yTicksOverride) && yTicksOverride.length)? yTicksOverride.slice() : niceTicksSafe(z0,z1,6);
  yticks=yticks.filter(v=>v>=z0-eps && v<=z1+eps);
  if(!yticks.length || !approxEq(yticks[0],z0)) yticks.unshift(z0);

  const tickLen=12;
  xticks.forEach(v=>{
    const x=sx(v);
    axis(x, xAxisY, x, xAxisY + tickLen, 'tick-mark');
    axis(M.left, xAxisY, M.left + (W - M.left - M.right), xAxisY, 'grid');
    axis(M.left, M.top, M.left + (W - M.left - M.right), M.top, 'grid');
    if(!approxEq(v,x0)){
      const lblY=Math.min(H-6, xAxisY + tickLen + 18);
      const lbl=document.createElementNS('http://www.w3.org/2000/svg','text');
      lbl.setAttribute('x',x); lbl.setAttribute('y',lblY);
      lbl.setAttribute('class','tick-label'); lbl.setAttribute('text-anchor','middle');
      lbl.textContent=fmtTick(v); svg.appendChild(lbl);
    }
  });
  yticks.forEach(v=>{
    const y=sy(v);
    axis(yAxisX - tickLen, y, yAxisX, y, 'tick-mark');
    axis(M.left, y, M.left + (W - M.left - M.right), y, 'grid');
    if(!approxEq(v,z0)){
      const lblX=Math.max(6, yAxisX - tickLen - 10);
      const lbl=document.createElementNS('http://www.w3.org/2000/svg','text');
      lbl.setAttribute('x',lblX); lbl.setAttribute('y',y+5);
      lbl.setAttribute('class','tick-label'); lbl.setAttribute('text-anchor','end');
      lbl.textContent=fmtTick(v); svg.appendChild(lbl);
    }
  });

  const lenU=units==='US'?'ft':'m';
  const xMid=M.left + (W - M.left - M.right)/2;
  const xlab=document.createElementNS('http://www.w3.org/2000/svg','text');
  xlab.setAttribute('x',xMid);
  xlab.setAttribute('y', Math.min(H-8, xAxisY + tickLen + 38));
  xlab.setAttribute('class','axis-label'); xlab.setAttribute('text-anchor','middle');
  xlab.textContent=`Station (${lenU})`; svg.appendChild(xlab);

  const yMid=M.top + (H - M.top - M.bottom)/2;
  const ylabX=Math.max(12, yAxisX - tickLen - 56);
  const ylab=document.createElementNS('http://www.w3.org/2000/svg','text');
  ylab.setAttribute('x',ylabX); ylab.setAttribute('y',yMid);
  ylab.setAttribute('class','axis-label'); ylab.setAttribute('text-anchor','middle');
  ylab.setAttribute('transform',`rotate(-90 ${ylabX} ${yMid})`);
  ylab.textContent=`Elevation (${lenU})`; svg.appendChild(ylab);
}

function niceTicks(min,max,count){
  const span=max-min;
  if(!(span>0)) return [min,max];
  const step=Math.pow(10, Math.floor(Math.log10(span/Math.max(1,count-1))));
  const err=(span/(count-1))/step;
  const mult=(err>=7.5)?10:(err>=3)?5:(err>=1.5)?2:1;
  const niceStep=mult*step;
  const niceMin=Math.floor(min/niceStep)*niceStep;
  const niceMax=Math.ceil(max/niceStep)*niceStep;
  const ticks=[];
  for(let v=niceMin; v<=niceMax+1e-12; v+=niceStep) ticks.push(+v.toFixed(12));
  return ticks.length?ticks:[min,max];
}
function niceTicksSafe(min,max,count){
  const t=niceTicks(min,max,count);
  if(t.length<2){ return [min,max>min?max:min+1]; }
  return t;
}
function niceCeil(maxVal){
  const base=(maxVal>0?maxVal:1);
  const t=niceTicks(0,base,5);
  return t[t.length-1]||base;
}
function niceCeilPlusOneTick(maxVal){
  const base=(maxVal>0?maxVal:1);
  const t=niceTicks(0,base,5);
  let step=(t.length>=2)?(t[1]-t[0]):(base||1);
  if(!(step>0)) step=1;
  const top=(t[t.length-1]||0)+step;
  return {top,step};
}
function ticksFromStep(min,max,step){
  if(!(step>0)) step=1;
  const out=[]; for(let v=min; v<=max+1e-12; v+=step) out.push(+v.toFixed(12));
  return out;
}
function fmt(x){
  if(!Number.isFinite(x)) return '—';
  const ax=Math.abs(x);
  const d=(ax>=1000)?0:(ax>=100)?1:(ax>=10)?2:3;
  return x.toFixed(d);
}
function fmtTick(x){
  const ax=Math.abs(x);
  const d=(ax>=1000)?0:(ax>=100)?0:(ax>=10)?1:2;
  return x.toFixed(d);
}

/* Help modal */
const helpModal=document.getElementById('helpModal'),
      openHelp=document.getElementById('openHelp'),
      closeHelp=document.getElementById('closeHelp');
openHelp.addEventListener('click',(e)=>{ e.currentTarget.classList.add('clicked'); setTimeout(()=>e.currentTarget.classList.remove('clicked'),160); helpModal.style.display='flex'; document.body.classList.add('modal-open'); });
closeHelp.addEventListener('click',()=>{ helpModal.style.display='none'; document.body.classList.remove('modal-open'); });
helpModal.addEventListener('click',(e)=>{ if(e.target===helpModal){ helpModal.style.display='none'; document.body.classList.remove('modal-open'); }});

/* ===================== n Picker ===================== */
const nPickerModal=document.getElementById('nPickerModal');
const openNPicker=document.getElementById('openNPicker');
const closeNPicker=document.getElementById('closeNPicker');
const applyN=document.getElementById('applyN');
const applyCloseN=document.getElementById('applyCloseN');
const nCurVal=document.getElementById('nCurVal');
const nMinus=document.getElementById('nMinus');
const nPlus=document.getElementById('nPlus');
const nSearch=document.getElementById('nSearch');
const nCardGrid=document.getElementById('nCardGrid');
const nPickerMsg=document.getElementById('nPickerMsg');

let nPickerState = { seg: 'chan', anchor: 'typ', choiceId: null, value: 0.035 };

openNPicker.addEventListener('click', (e)=>{
  e.currentTarget.classList.add('clicked'); setTimeout(()=>e.currentTarget.classList.remove('clicked'),160);
  renderNCards(); syncNPickerFromInputs();
  nPickerModal.style.display='flex'; document.body.classList.add('modal-open');
  if(document.getElementById('hvnToggle').checked){
    nPickerMsg.textContent='Note: HVn is ON — LOB/Channel/ROB n values will not affect results until HVn is OFF.';
  }else{ nPickerMsg.textContent=''; }
});
closeNPicker.addEventListener('click', ()=>{ nPickerModal.style.display='none'; document.body.classList.remove('modal-open'); });

document.querySelectorAll('#nPickerModal .chips button').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('#nPickerModal .chips button').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active'); nPickerState.seg = btn.dataset.seg; syncNPickerFromInputs();
  });
});
document.querySelectorAll('#nPickerModal .preset').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('#nPickerModal .preset').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active'); nPickerState.anchor = btn.dataset.a;
    if(nPickerState.choiceId){
      const rec=N_CATALOG.find(r=>r.id===nPickerState.choiceId);
      if(rec){ const v=anchorToVal(rec.n, nPickerState.anchor); nPickerState.value=v; updateNVal(); }
    }
  });
});
nMinus.addEventListener('click', ()=>{ nPickerState.value = +(nPickerState.value - 0.001).toFixed(3); updateNVal(); });
nPlus.addEventListener('click', ()=>{ nPickerState.value = +(nPickerState.value + 0.001).toFixed(3); updateNVal(); });
nSearch.addEventListener('input', renderNCards);
applyN.addEventListener('click', (e)=>{ e.currentTarget.classList.add('clicked'); setTimeout(()=>e.currentTarget.classList.remove('clicked'),160); applyNToInputs(); });
applyCloseN.addEventListener('click', (e)=>{ e.currentTarget.classList.add('clicked'); setTimeout(()=>e.currentTarget.classList.remove('clicked'),160); applyNToInputs(); nPickerModal.style.display='none'; document.body.classList.remove('modal-open'); });

function syncNPickerFromInputs(){
  const v = nPickerState.seg==='lob' ? parseFloat(document.getElementById('nLOB').value)
        : nPickerState.seg==='rob' ? parseFloat(document.getElementById('nROB').value)
        : parseFloat(document.getElementById('nMC').value);
  nPickerState.value = Number.isFinite(v)? v : 0.035;
  nCurVal.textContent = nPickerState.value.toFixed(3);
}
function applyNToInputs(){
  const v = nPickerState.value.toFixed(3);
  if(nPickerState.seg==='lob') document.getElementById('nLOB').value = v;
  else if(nPickerState.seg==='rob') document.getElementById('nROB').value = v;
  else document.getElementById('nMC').value = v;
  compute();
}
function updateNVal(){ nCurVal.textContent = (+nPickerState.value).toFixed(3); }
function anchorToVal(nObj, a){ if(a==='min' && Number.isFinite(nObj.min)) return nObj.min; if(a==='max' && Number.isFinite(nObj.max)) return nObj.max; return nObj.typ; }

function renderNCards(){
  const query = nSearch.value.trim().toLowerCase();
  const groupsOrder=['Main Channels','Mountain Streams','Floodplains','Excavated or Dredged Channels','Lined or Constructed Channels'];
  const grouped = new Map(); for(const g of groupsOrder) grouped.set(g, []);
  N_CATALOG.forEach(r=>{
    if(query){
      const hay=(r.grp+' '+r.label).toLowerCase();
      if(!hay.includes(query)) return;
    }
    if(!grouped.has(r.grp)) grouped.set(r.grp, []);
    grouped.get(r.grp).push(r);
  });

  let html='';
  for(const g of groupsOrder){
    const arr=grouped.get(g)||[]; if(!arr.length) continue;
    html+=`<div class="grp"><h4>${g}</h4><div class="cards">`;
    for(const r of arr){
      const active = (nPickerState.choiceId===r.id) ? 'active' : '';
      const rng = `${Number.isFinite(r.n.min)?r.n.min.toFixed(3):'—'}–${Number.isFinite(r.n.max)?r.n.max.toFixed(3):'—'}`;
      html+= `<button class="cardBtn ${active}" data-id="${r.id}">
        <div class="lbl">${r.label}</div>
        <div class="sub">${g}</div>
        <div class="rng">Range ${rng} • Typical ${r.n.typ.toFixed(3)}</div>
      </button>`;
    }
    html+='</div></div>';
  }

  nCardGrid.innerHTML=html;
  nCardGrid.querySelectorAll('.cardBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      nCardGrid.querySelectorAll('.cardBtn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      const id=btn.getAttribute('data-id');
      nPickerState.choiceId=id;
      const rec=N_CATALOG.find(r=>r.id===id);
      if(rec){
        const v=anchorToVal(rec.n, nPickerState.anchor);
        nPickerState.value=v; updateNVal();
      }
    });
  });
}

/* Reset example */
function resetExample(){
  document.getElementById('units').value = 'US';
  document.getElementById('slope').value = '0.001';
  document.getElementById('nLOB').value = '0.100';
  document.getElementById('nMC').value = '0.035';
  document.getElementById('nROB').value = '0.100';
  document.getElementById('depth').value = 2.5;
  document.getElementById('discharge').value = 0;
  const qToggle = document.getElementById('specifyQ'); qToggle.checked = false; updateQModeUI(false);
  document.getElementById('N_LOB').value = '1';
  document.getElementById('N_CHAN').value = '1';
  document.getElementById('N_ROB').value = '1';

  const pmOff=document.getElementById('pmOff');
  const pmXS=document.getElementById('pmXS');
  const pmSlices=document.getElementById('pmSlices');
  pmOff.checked=true; pmXS.checked=false; pmSlices.checked=false;

  const hvn=document.getElementById('hvnToggle'); hvn.checked=false; updateHVnUI(false);

  ineffectiveAreas = []; obstructions = [];
  levees = { left:{enabled:false, station:null, crest:null}, right:{enabled:false, station:null, crest:null} };
  renderIFATable(); renderObsTable(); renderLevTable();

  tableBody.innerHTML = '';
  const sample = [
    [-40, 3, '', ''],
    [-10, 2, 'LB', ''],
    [-5.5,0.5, '', ''],
    [ 0, 0, '', ''],
    [ 5.5,0.5, '', ''],
    [ 10, 2, 'RB', ''],
    [ 40, 3, '', '']
  ];
  for (const [x,z,t,nv] of sample) addRow(x, z, t, nv);
  ensureTrailingBlankRow();
  clearCellSelection();
  updateSliceOptionStates();
  compute();
}
/* ===================== INIT ===================== */
function init(){
  fillSliceSelect(document.getElementById('N_LOB'),1);
  fillSliceSelect(document.getElementById('N_CHAN'),1);
  fillSliceSelect(document.getElementById('N_ROB'),1);
  renderIFATable(); renderObsTable(); renderLevTable();
  resetExample();
  ensureTrailingBlankRow();
  updateSliceOptionStates();
  harmonizeButtons();
}
init();

/* ===================== USGS 3DEP MODAL INTEGRATION ===================== */

/** Open the 3DEP popover unless Designer → Update XS Data is ON */
(function wireUsgsImport(){
  const openBtn = document.getElementById('open3DEP');
  const modal = document.getElementById('usgsModal');
  const frame = document.getElementById('usgsFrame');

  function openModal(){
    frame.src = 'usgs.html?embedded=1';
    modal.style.display = 'flex';
    document.body.classList.add('modal-open');
  }
  function closeModal(){
    modal.style.display = 'none';
    document.body.classList.remove('modal-open');
    try{ frame.src = 'about:blank'; }catch(_){}
  }

  function unitsLabel(){ return (document.getElementById('units')?.value || 'US'); } // 'US' or 'SI'
  function mToFt(x){ return x*3.280839895013123; }
  function ftToM(x){ return x*0.3048; }
  function round3(x){ return Number.isFinite(+x) ? (+x).toFixed(3) : ''; }

  /** Replace XS table with imported samples; clear Stage and n */
  function applySamples(samples, srcUnits){
    if(!Array.isArray(samples) || !samples.length) return;
    const want = unitsLabel(); // 'US' => ft, 'SI' => m
    const fromFeet = (srcUnits === 'feet');
    const fromMeters = !fromFeet; // default meters
    const convert = (v)=>{
      if(want==='US' && fromMeters) return mToFt(v);
      if(want==='SI' && fromFeet ) return ftToM(v);
      return v;
    };
    // wipe and refill
    const tbody = document.querySelector('#xsTable tbody');
    if(!tbody) return;
    tbody.innerHTML = '';
    let n=0;
    for(const s of samples){
      const st = Number(s.station), el = Number(s.elevation);
      if(!Number.isFinite(st) || !Number.isFinite(el)) continue;
      addRow(round3(convert(st)), round3(convert(el)), '', ''); // Stage & n cleared
      n++;
    }
    ensureTrailingBlankRow();
    renumberIDs();
    clearCellSelection();
    compute();
    const msgEl = document.getElementById('messages');
    if(msgEl) msgEl.textContent = `Imported ${n} point(s) from USGS 3DEP. Mark LB and RB to compute.`;
  }

  // Open button
  if(openBtn){
    openBtn.addEventListener('click', (e)=>{
      e.currentTarget.classList.add('clicked'); setTimeout(()=>e.currentTarget.classList.remove('clicked'),160);
      const auto = document.getElementById('designerAutoApply');
      if(auto && auto.checked){
        alert('Turn off "Update XS Data" in the Designer tab before importing data from 3DEP.');
        return;
      }
      openModal();
    });
  }

  // Click outside iframe closes modal
  if(modal){
    modal.addEventListener('click', (e)=>{ if(e.target===modal) closeModal(); });
  }

  // Listen for messages from embedded usgs.html
  window.addEventListener('message', (evt)=>{
    const srcWin = frame?.contentWindow;
    if(!srcWin || evt.source !== srcWin) return; // only accept from our iframe
    const data = evt.data || {};
    if(data.type === 'usgs-import'){
      const samples = Array.isArray(data.samples) ? data.samples : [];
      const srcUnits = (data.units === 'feet') ? 'feet' : 'meters';
      applySamples(samples, srcUnits);
      closeModal();
    }else if(data.type === 'usgs-close-request'){
      closeModal();
    }
  });
})();
</script>
</body>
</html>
